<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>图分析算法及工具总结</title>
      <link href="/2018/05/25/graph-analysis/"/>
      <url>/2018/05/25/graph-analysis/</url>
      <content type="html"><![CDATA[<p>图分析是知识图谱（Knowledge Graph）图结构消费的重要组成部分，基于图分析算法的应用近年来层出不穷，比如：Palantir利用关联分析指导复杂战场环境下的军事行动、天眼查发现企业关联关系、拓尔思水晶球、宜信金融反欺诈等等。</p><p>本文首先对图分析涉及的组成部分、算法以及阅读资源进行归纳总结，然后介绍现有的图分析工具。后期将结合<a href="https://github.com/sparkling-graph/sparkling-graph" target="_blank" rel="noopener">sparking-graph</a>工具，详细介绍图分析领域每个组成的算法实现以及应用案例。</p><a id="more"></a><h3 id="图分析"><a href="#图分析" class="headerlink" title="图分析"></a>图分析</h3><h4 id="图度量-Graph-measures"><a href="#图度量-Graph-measures" class="headerlink" title="图度量 Graph measures"></a>图度量 Graph measures</h4><h5 id="节点度量-Vertex-measures"><a href="#节点度量-Vertex-measures" class="headerlink" title="节点度量 Vertex measures"></a>节点度量 Vertex measures</h5><ul><li>度中心性 Degree centrality</li><li>紧密中心性 Closeness centrality</li><li>特征向量中心性 Eigenvector centrality</li><li>HITS</li><li>Neighbordhood Connectivity</li><li>Vertex Edbeddednes</li><li>Local Clustering Coefficient</li></ul><h5 id="边度量-Edges-measures"><a href="#边度量-Edges-measures" class="headerlink" title="边度量 Edges measures"></a>边度量 Edges measures</h5><ul><li>Adamic/Adar</li><li>Common Neighbours</li></ul><h5 id="图度量-Graph-measures-1"><a href="#图度量-Graph-measures-1" class="headerlink" title="图度量 Graph measures"></a>图度量 Graph measures</h5><ul><li>Freeman’s network centrality</li><li>Modularity</li></ul><h4 id="最短路径-Shortest-paths"><a href="#最短路径-Shortest-paths" class="headerlink" title="最短路径 Shortest paths"></a>最短路径 Shortest paths</h4><h4 id="社区发现-Community-detection"><a href="#社区发现-Community-detection" class="headerlink" title="社区发现 Community detection"></a>社区发现 Community detection</h4><h4 id="频繁子图模式-Frequent-graph-pattern"><a href="#频繁子图模式-Frequent-graph-pattern" class="headerlink" title="频繁子图模式 Frequent graph pattern"></a>频繁子图模式 Frequent graph pattern</h4><ul><li>Apriori-based</li><li>Pattern growth</li></ul><h4 id="链接预测-Link-Prediction"><a href="#链接预测-Link-Prediction" class="headerlink" title="链接预测 Link Prediction"></a>链接预测 Link Prediction</h4><h3 id="图工具"><a href="#图工具" class="headerlink" title="图工具"></a>图工具</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://itimetraveler.github.io/2016/11/21/%E5%9F%BA%E4%BA%8E%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95%E5%92%8C%E5%9B%BE%E5%88%86%E6%9E%90Neo4j%E8%A7%A3%E8%AF%BB%E3%80%8A%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B/#%E5%AF%BC%E8%AF%BB" target="_blank" rel="noopener">基于社区发现算法和图分析Neo4j解读《权力的游戏》</a></li><li><a href="http://sparkling-graph.readthedocs.io" target="_blank" rel="noopener">http://sparkling-graph.readthedocs.io</a></li></ul>]]></content>
      
      <categories>
          
          <category> 知识图谱 </category>
          
          <category> 图分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图计算 </tag>
            
            <tag> 图挖掘 </tag>
            
            <tag> Spark GraphX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scala 隐式转换implicit详解</title>
      <link href="/2018/05/24/scala-implicit/"/>
      <url>/2018/05/24/scala-implicit/</url>
      <content type="html"><![CDATA[<p>最近在使用<code>Spark-GraphX</code>做图相关的算法分析，想着深入看看源码的实现。由于对<code>Scala</code>不熟悉，只能边看源码边去了解<code>Scala</code>的特性。在分析过程中，发现很多地方使用<code>implicit</code>关键词，就想深入了解下<code>implicit</code>。</p><a id="more"></a><h3 id="Implicit简介"><a href="#Implicit简介" class="headerlink" title="Implicit简介"></a>Implicit简介</h3><p><strong>implicit</strong>，即隐式转换，是支撑<code>Scala</code>易用、容错以及灵活语法的基础。</p><blockquote><p>Scala的隐式转换系统定义了一套良好的查找机制，当代码出现类型编译错误时，编译器试图去寻找一个隐式<code>implicit</code>的转换方法，转换出正确的类型，从而使得编译器能够自我修复，完成编译。</p></blockquote><p>比如，在<code>Spark</code>源码中，经常会发现<code>RDD</code>这个类没有<code>reduceByKey</code>、<code>groupByKey</code>等方法定义，但是却可以在<code>RDD</code>上调用这些方法。这就是<code>Scala</code>隐式转换导致的。</p><p>参考<code>Spark</code>源码<code>core/src/main/scala/org/apache/spark/rdd/RDD.scala</code>文件，在<code>RDD</code>这个对象上定义了一个<code>rddToPairRDDFunctions</code>隐式转换（在1.3版本之前，该隐式转换定义在SparkContext对象中）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines implicit functions that provide extra functionalities on RDDs of specific types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, [[RDD.rddToPairRDDFunctions]] converts an RDD into a [[PairRDDFunctions]] for</span></span><br><span class="line"><span class="comment"> * key-value-pair RDDs, and enabling extra functionalities such as `PairRDDFunctions.reduceByKey`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RDD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> <span class="type">CHECKPOINT_ALL_MARKED_ANCESTORS</span> =</span><br><span class="line">    <span class="string">"spark.checkpoint.checkpointAllMarkedAncestors"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following implicit functions were in SparkContext before 1.3 and users had to</span></span><br><span class="line">  <span class="comment">// `import SparkContext._` to enable them. Now we move them here to make the compiler find</span></span><br><span class="line">  <span class="comment">// them automatically. However, we still keep the old functions in SparkContext for backward</span></span><br><span class="line">  <span class="comment">// compatibility and forward to the following functions directly.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">rddToPairRDDFunctions</span></span>[<span class="type">K</span>, <span class="type">V</span>](rdd: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)])</span><br><span class="line">    (<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], vt: <span class="type">ClassTag</span>[<span class="type">V</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>): <span class="type">PairRDDFunctions</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">PairRDDFunctions</span>(rdd)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>rddToPairRDDFunctions</code>隐式转换，即将<code>RDD[(K, V)]</code>类型的rdd转换为<code>PairRDDFunctions</code>对象，从而可以在原始的rdd对象上调用<code>reduceByKey</code>之类的方法。</p><p>那为什么执行完<code>reductByKey</code>方法后，返回的还是原始的<code>rdd</code>对象了？那是因为每次执行完<code>PairRDDFunctions</code>对象方法后，会返回<code>rdd</code>对象。</p><p>类型隐式转换是在需要的时候才会触发，如果调用需要进行隐式转换的方法，隐式转换才会进行，否则还是传统的RDD类型的对象。</p><p>隐式转换对于代码重构提供了一种新的思路，比如公司有一个历时悠久的用户认证系统，各大业务系统一般会引入以下认证服务接口进行认证授权：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpAuthParam</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">HttpAuthParam</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是随着业务的发展，有些需要支持<code>TCP</code>协议的授权认证。一种方法是在<code>IAuthService</code>接口对<code>auth</code>方法进行重载，以满足<code>TCP</code>参数形式，那么就有：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">HttpAuthParam</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新版中支持对tcp消息鉴权的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">TcpAuthMsg</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法的问题在于，一旦业务发生变化，出现了新的参数，势必要修改<code>IAuthService</code>接口，添加新的接口方法，导致接口不稳定。</p><p>我们可以定义一个通用稳定的认证授权接口：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthParam</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 稳定的授权接口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">AuthParam</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口服务实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthService</span> <span class="keyword">extends</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">AuthParam</span>) = &#123;</span><br><span class="line">        println(<span class="string">"默认鉴权服务请求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对<code>AuthService</code>类进行隐式转换，增加<code>TCP</code>服务鉴权方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpAuthMsg</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tcpAuthService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式类转换</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpAuth</span>(<span class="params">authService: <span class="type">AuthService</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">TcpAuthMsg</span>) = &#123;</span><br><span class="line">println(<span class="string">"TCP鉴权服务请求"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以在需要调用TCP方式时导入该隐式转换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入隐式转换</span></span><br><span class="line"><span class="keyword">import</span> tcpAuthService._</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Tcp授权认证</span></span><br><span class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">TcpAuthMsg</span>()</span><br><span class="line"><span class="keyword">val</span> authService = <span class="keyword">new</span> <span class="type">AuthService</span>()</span><br><span class="line">authService.auth(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果:</span></span><br><span class="line"><span class="comment">// &gt; scala auth_implicit.scala</span></span><br><span class="line"><span class="comment">// TCP鉴权服务请求</span></span><br></pre></td></tr></table></figure><p>通过这个例子可知，通过类的隐式转换可以在不修改原有系统代码之下，对类进行方法重载，提升接口的稳定性。</p><p>当然，万事都是一把双刃剑，<code>implicit</code>使得Scala变的非常灵活，但增加了开发者阅读代码的难度，因为你不知道作者在哪些地方实现了<code>implicit</code>。</p><p>下面，就让我们来详细看看Scala里支持哪些<code>implicit</code>类型，以及应用隐式转换规则的限定条件。</p><h3 id="隐式转换类型"><a href="#隐式转换类型" class="headerlink" title="隐式转换类型"></a>隐式转换类型</h3><p>Scala隐式转换类型主要包括以下几种类型：隐式参数、隐式试图、隐式类。</p><h4 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h4><blockquote><p>隐式参数是在编译器找不到函数需要某种类型的参数时的一种修复机制。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(amout: <span class="type">Float</span>)(<span class="keyword">implicit</span> rate: <span class="type">Float</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(amout * rate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 隐式参数</span></span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">val</span> r = <span class="number">0.13</span>F  <span class="comment">// 定义隐式变量</span></span><br><span class="line">        foo(<span class="number">10</span>)  <span class="comment">// 输出1.3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>foo</code>参数中申明了隐式参数<code>rate</code>（即用<code>implicit</code>标记），在调用<code>foo</code>方法时，Scala编译器会从当前作用域中寻找一个相同类型的隐式变量，作为调用参数。如果没有找到找到，则会报错。</p><h4 id="隐式视图"><a href="#隐式视图" class="headerlink" title="隐式视图"></a>隐式视图</h4><blockquote><p>隐式视图，是指把一种类型自动转换到另外一种类型，以符合表达式的要求。</p></blockquote><p>隐式视图定义一般用如下形式：<code>implicit def &lt;ConversionName&gt; (&lt;argumentName&gt;: OriginalType): ViewType</code>。在需要的时候，如果隐式作用域里存在这个定义，它会隐式地把 <code>OriginalType</code> 类型的值转换为<code>ViewType</code> 类型的值。</p><p>隐式视图包含两种转换类型：隐式类型转换以及隐式方法调用。</p><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><blockquote><p>隐式类型转换是编译器发现传递的数据类型与申明不一致时，编译器在当前作用域查找类型转换方法，对数据类型进行转换。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Int</span></span>(d: <span class="type">Double</span>) = d.toInt</span><br><span class="line">    <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">3.5</span></span><br><span class="line">    println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>i</code>申明为<code>Int</code>类型，但是赋值<code>Double</code>类型数据，显然编译通不过。这个时候可以借助隐式类型转换，定义<code>Double</code>转<code>Int</code>规则，编译器就会自动查找该隐式转换，将<code>3.5</code>转换成<code>3</code>，从而达到编译器自动修复效果。</p><h5 id="隐式方法调用"><a href="#隐式方法调用" class="headerlink" title="隐式方法调用"></a>隐式方法调用</h5><blockquote><p>隐式方法调用是当编译器发现一个对象存在未定义的方法调用时，就会在当前作用域中查找是否存在对该对象的类型隐式转换，如果有，就查找转换后的对象是否存在该方法，存在，则调用。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drinking</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"I can drinking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Crow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">drinking</span></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式方法调用</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">extendSkill</span></span>(c: <span class="type">Crow</span>) = <span class="keyword">new</span> <span class="type">Horse</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 隐式转换调用类中不存在的方法</span></span><br><span class="line">    <span class="keyword">import</span> drinking._</span><br><span class="line">    <span class="keyword">var</span> crow = <span class="keyword">new</span> <span class="type">Crow</span>()</span><br><span class="line">    crow.drinking()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>crow</code>对象并没有<code>drinkging()</code>方法定义，但是通过隐式规则转换，可以扩展<code>crow</code>对象功能，使其可以拥有<code>Horse</code>对象的功能。</p><h4 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h4><blockquote><p>Scala 2.10引入了一种叫做隐式类的新特性。隐式类指的是用implicit关键字修饰的类。在对应的作用域内，带有这个关键字的类的主构造函数可用于隐式转换。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Crow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">crow_eval</span></span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Parrot</span>(<span class="params">animal: <span class="type">Crow</span></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(say: <span class="type">String</span>): <span class="type">Unit</span> = &#123;println(<span class="string">s"I have the skill of Parrot: <span class="subst">$say</span>"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 隐式类</span></span><br><span class="line">    <span class="keyword">import</span> crow_eval._</span><br><span class="line">    crow.say(<span class="string">"balabala"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建隐式类时，只需要在对应的类前加上<code>implicit</code>关键字。</p><p>使用隐式类时，需要注意以下几点：</p><ul><li>构造参数有且只有一个，且为非隐式参数</li><li>隐式类必须被定义在类、伴生对象和包对象里</li><li>隐式类不能是<code>case class</code>（<code>case class</code>会自动生成伴生对象，与上一条矛盾）</li><li>作用域内不能有与之同名的标识符</li></ul><h3 id="隐式解析机制"><a href="#隐式解析机制" class="headerlink" title="隐式解析机制"></a>隐式解析机制</h3><p>编译器是如何查找到缺失信息的，解析具有以下两种规则：</p><ol><li><p>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）</p></li><li><p>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。</p><p>类型的作用域是指与该类型相关联的全部伴生模块，一个隐式实体的类型T，它的查找范围如下：</p><ul><li>如果T被定义为<code>T with A with B with C</code>，那么A、B、C都是T的部分，在T的隐式解析过程中，它们的伴生对象都会被搜索</li><li>如果T是参数化类型，那么类型参数和与类型参数相关联的部分都算作T的部分，比如<code>List[String]</code>的隐式搜索会搜索List的伴生对象和String的伴生对象</li><li>如果T是一个单例类型<code>p.T</code>，即T是属于某个p对象内，那么这个p对象也会被搜索</li><li>如果T是个类型注入<code>S#T</code>，那么S和T都会被搜索</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>implicit</code>是Scala语言中处理编译类型错误的一种修复机制，利用该机制，可以编写出任意参数和返回值的多态方法（<code>Ad-hoc polymorphism</code>任意多态），实现任意多态。</p><p>隐式转换一般需要具备以下前提条件：</p><ul><li>不存在二义性</li><li>隐式操作不能嵌套使用，比如需要<code>C</code>类型参数，而实际类型为<code>A</code>，作用域内存在<code>A =&gt; B</code>,<code>B =&gt; C</code>的隐式方法，Scala编译器不会尝试先调用<code>A =&gt; B</code> ,再调用<code>B =&gt; C</code>。 </li><li>代码能够在不使用隐式转换的前提下能编译通过，就不会进行进行隐式转换</li></ul><p>在实际开发过程中，如果对隐式规则掌握不清楚，往往出了问题会无从查起，笔者建议谨慎使用。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/1d119c937015" target="_blank" rel="noopener">Scala中的Implicit详解</a></li><li><a href="https://docs.scala-lang.org/zh-cn/overviews/core/implicit-classes.html" target="_blank" rel="noopener">https://docs.scala-lang.org/zh-cn/overviews/core/implicit-classes.html</a></li><li><a href="https://blog.csdn.net/oopsoom/article/details/24643869" target="_blank" rel="noopener">scala implicit 隐式转换</a></li></ol>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> implicit </tag>
            
            <tag> 隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 小整数与大整数的处理机制以及整体解释与逐行解释的区别</title>
      <link href="/2018/05/17/py-int-confusing/"/>
      <url>/2018/05/17/py-int-confusing/</url>
      <content type="html"><![CDATA[<p>分析以下代码的执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line">print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line">print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line">print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><a id="more"></a><p>保存为<code>test.py</code>并执行<code>python3 test.py</code>，运行结果如下 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a is b True</span><br><span class="line">c is d True</span><br><span class="line">a is e True</span><br><span class="line">c is f False</span><br><span class="line">f is g True</span><br></pre></td></tr></table></figure><p>这里先说明下<code>is</code>和<code>==</code>的区别：</p><ul><li><code>is</code>操作符是比较两个实例对象是不是同一个对象，即内存地址是否相同</li><li><code>==</code>操作符是比较两个实例对象内容是不是一样，即内存地址可能不一样</li></ul><p>分析以上结果可知，变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>是同一个对象。但<strong>为什么<code>a</code>和<code>e</code>是同一个对象，而<code>c</code>和<code>f</code>不是同一个对象？</strong></p><p>对以上代码，在终端逐行执行，看看结果会是怎么样的。执行过程及结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    e = <span class="number">256</span></span><br><span class="line"><span class="meta">... </span>    f = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    g = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">a <span class="keyword">is</span> b <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> d <span class="keyword">False</span></span><br><span class="line">a <span class="keyword">is</span> e <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> f <span class="keyword">False</span></span><br><span class="line">f <span class="keyword">is</span> g <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>为啥<code>c</code>和<code>d</code>不是同一个对象了？</strong></p><p>解释以上结果，需要了解<code>Python</code>语言的<strong>小整数与大整数</strong>的处理机制以及<strong>整体解释与逐行解释</strong>的区别。</p><h3 id="小整数与大整数"><a href="#小整数与大整数" class="headerlink" title="小整数与大整数"></a>小整数与大整数</h3><p>学过<code>java</code>的都知道，在<code>JDK5</code>中，为<code>Integer</code>的操作引入了一个新的特性，用来节省内存和提高性能。<code>[-128, 127]</code>之间的整形对象在内部实现中通过使用相同的对象引用实现了缓存和重用。为什么对这个区间范围的整数进行缓存？主要是因为这个范围的整数值使用最广泛（<code>JDK6</code>之后可以通过<code>jvm</code>启动参数设置最大值）。</p><p>在<code>Python</code>中，同样采用了类似的整形缓存机制。<code>Python</code>将整数的定义细分为小整数和大整数，前者整数值范围为<code>[-5, 257)</code>，其余整数为后者。</p><h4 id="小整数对象缓存池"><a href="#小整数对象缓存池" class="headerlink" title="小整数对象缓存池"></a>小整数对象缓存池</h4><p><code>Python</code>将小整数缓存到一个特定的<code>small_ints</code>链表中，该链表会存在于<code>Python</code>解释器的整个生命周期，当需要使用小整数时，就去该链表中获取。简单来说，<strong>小整数对象会在Python全局解析器范围内被重复引用，且永远不会被GC回收</strong>。</p><h4 id="通用整数对象缓存池"><a href="#通用整数对象缓存池" class="headerlink" title="通用整数对象缓存池"></a>通用整数对象缓存池</h4><p><code>Python</code>运行环境会为大整数对象分配一定的缓存内存空间，该内存空间会被大整数对象轮流使用，直到占满为止，再继续则开辟一块新的内存空间。通过分析<code>Python</code>源码可知，通用整数对象缓存池的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>PyIntBlock</code>结构体定义了一个<code>PyIntObject</code>数组和指向下一个<code>PyIntBlock</code>结构的指针<code>*next</code>。每个block大约可以存放82个<code>PyIntObject</code>。<code>block_list</code>用于维护分配给<code>PyIntObject</code>所有的内存空间，<code>free_list</code>则用于维护<code>PyIntObject</code>可用的剩余内存空间。</p><ul><li><p>当<code>free_list</code>为<code>NULL</code>时，<code>Python</code>会重新<code>malloc</code>一个新的block出来。</p></li><li><p>当一个大整数对象的引用计数为0需要被回收时，其占用的内存空间并不会被回收，而是放到<code>free_list</code>数组中，供新创建的整数对象使用，从而减少内存创建、释放带来的开销。</p></li></ul><p>综上所述，可以解释变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>为什么是同一个对象。但是还不足以解释<code>c/f</code>以及在终端执行时<code>c/d</code>的结果。这就需要了解<strong>Python的解析模式</strong>——整体解释和逐行解释。</p><h3 id="整体解释与逐行解释"><a href="#整体解释与逐行解释" class="headerlink" title="整体解释与逐行解释"></a>整体解释与逐行解释</h3><p><strong>整体解释</strong>指的通过应用程序的方式来运行Python代码，而<strong>逐行解释</strong>是在交互式解释器中执行Python代码。在Python中，解析器的<strong>编译单元是一个函数</strong>（Python顶层代码也被当作一个函数来进行编译）。每个函数单独编译后会得到一个<code>PyFunctionObject</code>对象，该对象包含了字节码、常量池等信息。</p><p>每个<code>PyFunctionObject</code>都拥有一个独立的常量池，如果在同一个<code>PyFunctionObject</code>里创建了值相同的常量，那么这些常量只会在常量池里出现一份。</p><p>由此可知，问题中总共包含两个<code>PyFunctionObject</code>对象——由顶层函数和<code>foo</code>函数编译。顶层变量<code>c/d</code>和位于<code>foo</code>函数中的<code>f/g</code>分别位于两个不同的<code>PyFunctionObject</code>对象中，虽然值相同，但是内存地址不同。这就解释了<code>c/f</code>的运行结果。那为什么<code>a/e</code>两个变量是相同的对象了，那是因为小整数是全局解释器缓存的！</p><p>那么就剩一个问题了，为什么在交互式命令行终端<code>c/d</code>不是同一个对象了？</p><p>那是因为在交互式中，每输入一行语句就会立即执行，即<strong>编译单元是一行语句</strong>，每执行一行语句就会得到一个<code>PyFunctionObject</code>对象。注意，这里所说的“一行”是指的一次完整性输入。</p><p>综上所述，可以得到以下结论：</p><ul><li>整体解释是以函数为编译单元的，而交互式终端是以一行语句输入为编译单元，每个编译单元具有独立的常量池</li><li>小整数范围为<code>[-5, 257)</code>，缓存在全局解释器中，而大整数缓存在编译单元中</li></ul><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>修改<code>foo</code>函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(h=<span class="number">256</span>, i=<span class="number">257</span>)</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">'a is h'</span>, a <span class="keyword">is</span> h)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'c is i'</span>, c <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'f is i'</span>, f <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p> 运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span> h <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> i <span class="keyword">True</span></span><br><span class="line">f <span class="keyword">is</span> i <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 你不知道的Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小整数 </tag>
            
            <tag> 大整数 </tag>
            
            <tag> 整数缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode31 下一个排列</title>
      <link href="/2018/05/04/n31-next-permutation/"/>
      <url>/2018/05/04/n31-next-permutation/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-permutation/description/" target="_blank" rel="noopener">LeetCode第31题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有数字序列n~1~n~2~n~3~…n~i~…n~m~，定义左边为高位，右边为低位。从低位向高位逐位比较，</p><p>如果n~i~ &lt;= n~i-1~，则继续向高位进位比较下一组（即i–）；</p><p>如果n~i~&gt;n~i-1~，则在n~i~ ~ n~m~之间寻找比n~i-1~大的最小数字，并与之交换。</p><p>最后对n~i~ ~ n~m~数字序列按从小到大进行排序，得到最终数字排列即为答案。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 从i -&gt; n中选择比nums[i-1]大的最小数字</span></span><br><span class="line">                j = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= i:</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &lt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    nums[i<span class="number">-1</span>], nums[j] = nums[j], nums[i<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 i -&gt; n 进行翻转，按从小到大排列</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; (len(nums)<span class="number">-1</span>-i) / <span class="number">2</span>:</span><br><span class="line">            nums[i+k], nums[len(nums)<span class="number">-1</span>-k] = nums[len(nums)<span class="number">-1</span>-k], nums[i+k]</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode30 与所有单词相关联的字串</title>
      <link href="/2018/05/03/n30-substring-with-concatenation-of-all-words/"/>
      <url>/2018/05/03/n30-substring-with-concatenation-of-all-words/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="noopener">LeetCode第30题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个字符串 <strong>s</strong> 和一些<strong><em>长度相同</em></strong>的单词 <strong>words。</strong>在 <strong>s</strong> 中找出可以恰好串联 <strong>words</strong> 中所有单词的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出: [0,9]</span><br><span class="line">解释: 从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先将<code>words</code>转换成字典<code>word_dict</code>，<code>key</code>为单词，<code>value</code>为单词出现的次数。以<code>words</code>所有单词总长度为窗口，截取字符串<code>s</code>，然后再将子串以单词长度进行分割。如果分割出的子串包含于<code>words</code>中，则<code>word_dict</code>计数相应的减1（计数等于0时，移除该单词），否则进行下一窗口截取。如果最后<code>word_dict</code>为空，则表示找到字符串可以用<code>words</code>所有单词完全匹配。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        word_num = len(words)</span><br><span class="line">        word_len = len(words[<span class="number">0</span>])</span><br><span class="line">        n_word_len = word_len * word_num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        d = word_dict.copy()</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p+n_word_len]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 每隔word_len进行截取，判断word_dict是否包含该子串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(word_num):</span><br><span class="line">                item = sub[i*word_len: (i+<span class="number">1</span>)*word_len]</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[item] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[item] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> d[item]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果word_dict为空，找到子串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">                res.append(p)</span><br><span class="line">                </span><br><span class="line">            d = word_dict.copy()</span><br><span class="line"> </span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>本题需要匹配的<code>words</code>列表单词长度是<strong>相同</strong>的，如果不相同了？</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barrfothefoobarman&quot;,</span><br><span class="line">  words = [&quot;fo&quot;,&quot;barr&quot;]</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 从索引 0 开始的子串为barrfo，可以用words所有单词完全匹配。</span><br></pre></td></tr></table></figure><p>基于以上思路，一种方法是修改子串的校验方法，使用逐字比较。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        n_word_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            n_word_len += len(word)</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p + n_word_len]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 逐字比较</span></span><br><span class="line">            <span class="keyword">if</span> self.word_cmp(sub, word_dict):</span><br><span class="line">                res.append(p)</span><br><span class="line"></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word_cmp</span><span class="params">(self, s, word_dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        d = word_dict.copy()</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s):</span><br><span class="line">            sub = s[<span class="number">0</span>:i]</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sub] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[sub] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> d[sub]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.word_cmp(s[i:], d):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode29 两数相除</title>
      <link href="/2018/05/01/n29-divide-two-integers/"/>
      <url>/2018/05/01/n29-divide-two-integers/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">LeetCode第29题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>除法是乘法的逆运算，假设 dividend / divisor = n，那么有dividend = divisor * n，亦可表示为n个数进行累加dividend = divisor + … + divisor。解答本题的基本思路即通过对除数进行累加直到超过被除数，累加的次数即为商。显然，这种方法运行效率不高，评测执行超时。那有没有什么方法在此算法基础上提升效率了，先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">求 12/2 的商，转换成加法，即：</span><br><span class="line">12 = 2 + 2 + 2 + 2 + 2 + 2</span><br><span class="line">共累加6次，即商为6。</span><br><span class="line"></span><br><span class="line">通过观察发现，每次都是累加同一个数字，能不能减少加法运算，快速逼近12？答案对除数进行移位操作。</span><br><span class="line"></span><br><span class="line">轮次  |     移位        |    商</span><br><span class="line">1        4 (2 &lt;&lt;= 1)       2 (1 &lt;&lt;= 1)</span><br><span class="line">2        8 (4 &lt;&lt;= 1)       4 (2 &lt;&lt;= 1)</span><br><span class="line">3        16 (8 &lt;&lt;= 1) 退出循环</span><br><span class="line"></span><br><span class="line">经过两轮循环，除数为8，商为4，余数为12 - 8 = 4。然后继续使用相同的方法计算4/2的商。</span><br><span class="line"></span><br><span class="line">轮次  |     移位    |    商</span><br><span class="line">1       4 (2 &lt;&lt;= 1)     2 (1 &lt;&lt;= 1)</span><br><span class="line">2       8 (4 &lt;&lt;= 1)  退出循环</span><br><span class="line"></span><br><span class="line">则12/2商为 4 + 2 = 6。通过此算法，共减少了3次加法运算。</span><br></pre></td></tr></table></figure><p>通过对除数进行移位操作可较少加法次数，从而提升算法执行效率。考虑到被除数或除数可能出现负数情况，可先计算商的正负情况，然后取被除数和除数的绝对值进行除法运算，最后再设置商的符号。</p><p>算法伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">令商result = 1 </span><br><span class="line">计算商是否为负数 neg = (dividend &lt; 0) ^ (divisor &lt; 0)</span><br><span class="line">取被除数、除数绝对值 dividend = abs(dividend), divisor = abs(divisor)</span><br><span class="line">假如 dividend &lt; divisor, 则返回0</span><br><span class="line">初始化count, n = 1, divisor</span><br><span class="line">while (n &lt;&lt; 1) &lt;= dividend</span><br><span class="line">   n &lt;&lt;= 1</span><br><span class="line">   count &lt;&lt;= 1</span><br><span class="line">result += count</span><br><span class="line">令dividend = dividend - n, 重复步骤4</span><br><span class="line">如果reg是负数, 则返回-result, 否则返回result (需考虑整数溢出情况)</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        neg  = (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>:  <span class="comment"># 当除数是1时，商直接设置为dividend</span></span><br><span class="line">            result = dividend</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="number">1</span></span><br><span class="line">            tmp = divisor</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;&lt; <span class="number">1</span>) &lt;= dividend:</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                result &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            result += self.divide(dividend - tmp, divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理正整数除法溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> result &gt;= <span class="number">2</span> ** <span class="number">31</span> <span class="keyword">and</span> <span class="keyword">not</span> neg:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -result <span class="keyword">if</span> neg <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><p>以上代码使用<code>Python3</code>编写，注意<code>Python3</code>没有<code>long</code>类型，<code>int</code>整形没有大小限制。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 除法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode25 k个一组翻转链表</title>
      <link href="/2018/04/20/n25-reverse-nodes-in-k-group/"/>
      <url>/2018/04/20/n25-reverse-nodes-in-k-group/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">LeetCode第25题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。<br>示例 :<br>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code><br>当 k = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code><br>当 k = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>说明:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">交换链表节点题</a>的延伸。本题解题思路可以采用递归法，先翻转前k个节点(如果链表小于k个节点，直接返回链表)，然后递归对其余节点进行翻转，最后将两者接上。<br>由于头节点可能会改变，所以在链表头部插入一个空节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        new_head.next = head</span><br><span class="line">        p = head</span><br><span class="line">        </span><br><span class="line">        node_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node_count &lt; k <span class="keyword">and</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            node_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node_count == k:</span><br><span class="line">    <span class="comment"># 对剩余的节点进行K-组翻转</span></span><br><span class="line">            current_node = self.reverseKGroup(p, k)</span><br><span class="line">    <span class="comment"># 对本次k节点进行翻转，并接上current_node</span></span><br><span class="line">            <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                temp = new_head.next</span><br><span class="line">                new_head.next = temp.next</span><br><span class="line">                temp.next = current_node</span><br><span class="line">                current_node = temp</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里需要将空节点指向current_node</span></span><br><span class="line">            new_head.next = current_node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode24 两两交换链表中的节点</title>
      <link href="/2018/04/15/n24-swap-nodes-in-pairs/"/>
      <url>/2018/04/15/n24-swap-nodes-in-pairs/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">LeetCode第24题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有P-&gt;A-&gt;B-&gt;C-&gt;…链表，交换A、B节点即把A.next指向C，B.next指向A，P.next指向B。算法步骤如下图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqdnfvn8p3j30nk0pgdgf.jpg" width="400"><br>在实现时，可以在头部添加一个空结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 插入一个空的节点，指向head</span></span><br><span class="line">        p = ListNode(<span class="number">0</span>)</span><br><span class="line">        p.next = head</span><br><span class="line">        head = p</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">and</span> p.next.next:</span><br><span class="line">            temp = p.next.next</span><br><span class="line">            p.next.next = p.next.next.next</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员密码</title>
      <link href="/2018/04/14/programmers-pwd/"/>
      <url>/2018/04/14/programmers-pwd/</url>
      <content type="html"><![CDATA[<p>这几天在<a href="https://www.v2ex.com/t/445123" target="_blank" rel="noopener">V2EX</a>上看到一个面向程序员的小游戏——在网页中找到一个隐藏的密码即可过关。游戏目前总共有两个level, level1有10道题，level2有5道题。游戏规则虽然简单，但是想要过关还是需要掌握不少知识，比如：’Chrome Developer Tools’工具使用、Baes64解码、图片隐写术等等。<br>游戏挺有意思的，在这里记录下，写者无心，读者请闭眼。</p><a id="more"></a><h2 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h2><p>进入游戏只有一个密码输入框，第一反应是打开开发者工具，寻找蛛丝马迹。通过细心观察，果然发现<code>Console</code>有信息打印，并且对源码进一步分析，游戏核心代码在<code>js/app/level.js</code>文件里。<code>level.js</code>粗略看下来，主要包含两部分重要信息：关卡通过对玩家输入的密码进行<code>md5</code>加密验证以及每个关卡执行的函数(存放在<code>LevelManager.prototype.levels</code>数组里)。<br>总体分析下来，得到的信息如下：<br>1）Console有信息提示<br>2）每个关卡的触发函数<br>3）md5加密</p><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1-0"></a>level1-0</h3><p>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p><h3 id="level1-1"><a href="#level1-1" class="headerlink" title="level1-1"></a>level1-1</h3><p>对<code>Console</code>打印的信息进行Base64解码 (为啥会想到Base64？因为字符最后的<code>=</code>号)<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m a programmer.</span><br></pre></td></tr></table></figure></p><h3 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h3><p>对<code>cGluZyB3d3cucHJvZ3JhbW1lcnBhc3N3b3JkLmNvbQ==</code>进行Base64解码，得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.programmerpassword.com</span><br></pre></td></tr></table></figure></p><p>进而在终端执行ping，获取ip地址<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47.104.152.148</span><br></pre></td></tr></table></figure></p><h3 id="level1-3"><a href="#level1-3" class="headerlink" title="level1-3"></a>level1-3</h3><p>本关卡没有在<code>Console</code>里打印信息，但是通过对关卡函数分析，本关卡在页面上插入了一段<code>html</code>代码，并且设置了透明样式。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码是123456</span><br></pre></td></tr></table></figure></p><h3 id="level1-4"><a href="#level1-4" class="headerlink" title="level1-4"></a>level1-4</h3><p><code>Console</code>打印了一串数字，使用<code>String.fromCharCode()</code>将十六进制整数转ascii码。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bug running</span><br></pre></td></tr></table></figure></p><h3 id="level1-5"><a href="#level1-5" class="headerlink" title="level1-5"></a>level1-5</h3><p>本关卡在页面上插入了一段<code>html</code>代码，只显示了一个<code>#</code>。开始以为是和<code>jQuery</code>的id选择器有关，结果答案却是<code>#</code>文字的RGB颜色值。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2f4584</span><br></pre></td></tr></table></figure></p><h3 id="level1-6"><a href="#level1-6" class="headerlink" title="level1-6"></a>level1-6</h3><p>图片的Base64编码，需要添加头部<code>data:image/jpeg;</code>。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">463700</span><br></pre></td></tr></table></figure></p><h3 id="level1-7"><a href="#level1-7" class="headerlink" title="level1-7"></a>level1-7</h3><p>访问<code>img.src</code>指定的url。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better to miss than to meet</span><br></pre></td></tr></table></figure></p><h3 id="level1-8"><a href="#level1-8" class="headerlink" title="level1-8"></a>level1-8</h3><p>在<code>Console</code>里输入<code>window.getPassword(&quot;H4sIAAAAAAAAC7MPcHq2ZWH987ndEfYA5w4bAwwAAAA=&quot;)</code><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25LTQWMP9Y</span><br></pre></td></tr></table></figure></p><h3 id="level1-9"><a href="#level1-9" class="headerlink" title="level1-9"></a>level1-9</h3><p>最坑爹的关卡，以为密码会隐藏在给出的PHP代码里，然而，然而，被坑了。。。把图片下载下来，然后使用十六进制编辑器打开图片，从jpg图片里可找到<code>cd /data/log/../www/; pwd</code>附加信息。<br>jpg隐写技巧原理可以参考这篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8JPEG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8Fpayload/" target="_blank" rel="noopener">隐写技巧-利用JPEG文件格式隐藏payload</a><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/www</span><br></pre></td></tr></table></figure></p><p>总结Level1关卡，整体难度其实并不高，只要善于使用谷歌开发者工具以及掌握Html&amp;Css、Base64编码、JPG隐写术等知识点就能轻松过关。</p><h2 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h2><p>Level2总共有5道题，虽然题目减少，但是难度较Level1提升了好几个档次。当然，坑更多…</p><h3 id="level2-0"><a href="#level2-0" class="headerlink" title="level2-0"></a>level2-0</h3><p>页面提示区显示了一段乱码，显然本关卡只需要解决乱码问题即可找到密码。<br>打开开发者工具，找到发起的ajax请求，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fqd3pnqa4xj30lq07aglt.jpg" alt="关卡请求"><br>通过分析可以发现，Html页面编码采用UTF-8，而ajax请求Http Response Content-Type Header设置了GBK编码类型，这就是导致乱码的原因。破解此题，只需如下操作：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd3urupjdj30lo0byaaj.jpg" alt="拷贝Curl请求"><br>右键拷贝curl请求，然后打开终端，执行curl请求：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fqd3xbjeqpj31kw02kdgb.jpg" alt="执行Curl请求"><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">春花秋月何时了</span><br></pre></td></tr></table></figure></p><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2-1"></a>level2-1</h3><p>本关卡提示信息是一张写有二进制的图片，显然第一反应是把图片上的二进制转成字符串，可以得到<code>error!</code>。经过试验，密码并不是<code>error!</code>。那么<code>error!</code>这几个字母是不是作者给我们的提示了，记过漫长时间的思考，终究没有找到答案。得放弃这个方向了，又是图片隐写术了？把图片下载下来，分析发现这是一张正常的图片，并没有添加额外的附加信息。又经过一段时间的思考，突然想到，是不是密码存放在图片属性里。立马右键图片，查看属性内容，果然图片添加了“备注”，心里一乐。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd4mgsottj30bm0i0jrr.jpg" alt=""><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCFHJJUKLI</span><br></pre></td></tr></table></figure></p><p>上文里其实介绍过JPG隐写术，本关卡也是隐写术的一种，使用<a href="http://www.impulseadventure.com/photo/jpeg-snoop.html" target="_blank" rel="noopener">JPEGsnoop</a>工具打开图片亦可查找到备注信息。</p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 程序员密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员密码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode23 合并K个有序链表</title>
      <link href="/2018/04/13/n23-merge-k-sorted-lists/"/>
      <url>/2018/04/13/n23-merge-k-sorted-lists/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第23题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>合并k个有序链表，返回合并后的排序链表。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第21题-合并两个有序链表</a>的扩展。所以，一种思路是采用两两合并的算法进行合并，但是算法复杂度较高。<br>另外一种思路是采用最小堆法，算法步骤如下：</p><ol><li>将k个链表的头结点放入最小堆；</li><li>从堆中取出最小元素并插入结果链表中;</li><li>如果取出的最小元素还有下一个元素，将其放入最小堆中;</li><li>执行步骤<code>2</code>，直到堆中元素全部被取出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化返回的链表</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化最小堆：取链表的头节点</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            n = lists[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 注意ListNode对象不能应用&lt;或者&gt;运算符，所以引入链表下标。通过(n.val, i)即可完成元素比较。</span></span><br><span class="line">            heapq.heappush(heap, (n.val, i, n)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次取出堆中最小的元素，插入到返回链表中，然后再将下一个节点插入最小堆中</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            _, i, min_node = heapq.heappop(heap)</span><br><span class="line">            p.next = min_node</span><br><span class="line">            p = min_node</span><br><span class="line">            <span class="keyword">if</span> min_node.next:</span><br><span class="line">                heapq.heappush(heap, (min_node.next.val, i, min_node.next))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
