<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Scala 隐式转换implicit</title>
      <link href="/2018/05/24/scala-implicit/"/>
      <url>/2018/05/24/scala-implicit/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> implicit </tag>
            
            <tag> 隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 小整数与大整数的处理机制以及整体解释与逐行解释的区别</title>
      <link href="/2018/05/17/py-int-confusing/"/>
      <url>/2018/05/17/py-int-confusing/</url>
      <content type="html"><![CDATA[<p>分析以下代码的执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line">print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line">print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line">print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><a id="more"></a><p>保存为<code>test.py</code>并执行<code>python3 test.py</code>，运行结果如下 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a is b True</span><br><span class="line">c is d True</span><br><span class="line">a is e True</span><br><span class="line">c is f False</span><br><span class="line">f is g True</span><br></pre></td></tr></table></figure><p>这里先说明下<code>is</code>和<code>==</code>的区别：</p><ul><li><code>is</code>操作符是比较两个实例对象是不是同一个对象，即内存地址是否相同</li><li><code>==</code>操作符是比较两个实例对象内容是不是一样，即内存地址可能不一样</li></ul><p>分析以上结果可知，变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>是同一个对象。但<strong>为什么<code>a</code>和<code>e</code>是同一个对象，而<code>c</code>和<code>f</code>不是同一个对象？</strong></p><p>对以上代码，在终端逐行执行，看看结果会是怎么样的。执行过程及结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    e = <span class="number">256</span></span><br><span class="line"><span class="meta">... </span>    f = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    g = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">a <span class="keyword">is</span> b <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> d <span class="keyword">False</span></span><br><span class="line">a <span class="keyword">is</span> e <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> f <span class="keyword">False</span></span><br><span class="line">f <span class="keyword">is</span> g <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>为啥<code>c</code>和<code>d</code>不是同一个对象了？</strong></p><p>解释以上结果，需要了解<code>Python</code>语言的<strong>小整数与大整数</strong>的处理机制以及<strong>整体解释与逐行解释</strong>的区别。</p><h3 id="小整数与大整数"><a href="#小整数与大整数" class="headerlink" title="小整数与大整数"></a>小整数与大整数</h3><p>学过<code>java</code>的都知道，在<code>JDK5</code>中，为<code>Integer</code>的操作引入了一个新的特性，用来节省内存和提高性能。<code>[-128, 127]</code>之间的整形对象在内部实现中通过使用相同的对象引用实现了缓存和重用。为什么对这个区间范围的整数进行缓存？主要是因为这个范围的整数值使用最广泛（<code>JDK6</code>之后可以通过<code>jvm</code>启动参数设置最大值）。</p><p>在<code>Python</code>中，同样采用了类似的整形缓存机制。<code>Python</code>将整数的定义细分为小整数和大整数，前者整数值范围为<code>[-5, 257)</code>，其余整数为后者。</p><h4 id="小整数对象缓存池"><a href="#小整数对象缓存池" class="headerlink" title="小整数对象缓存池"></a>小整数对象缓存池</h4><p><code>Python</code>将小整数缓存到一个特定的<code>small_ints</code>链表中，该链表会存在于<code>Python</code>解释器的整个生命周期，当需要使用小整数时，就去该链表中获取。简单来说，<strong>小整数对象会在Python全局解析器范围内被重复引用，且永远不会被GC回收</strong>。</p><h4 id="通用整数对象缓存池"><a href="#通用整数对象缓存池" class="headerlink" title="通用整数对象缓存池"></a>通用整数对象缓存池</h4><p><code>Python</code>运行环境会为大整数对象分配一定的缓存内存空间，该内存空间会被大整数对象轮流使用，直到占满为止，再继续则开辟一块新的内存空间。通过分析<code>Python</code>源码可知，通用整数对象缓存池的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>PyIntBlock</code>结构体定义了一个<code>PyIntObject</code>数组和指向下一个<code>PyIntBlock</code>结构的指针<code>*next</code>。每个block大约可以存放82个<code>PyIntObject</code>。<code>block_list</code>用于维护分配给<code>PyIntObject</code>所有的内存空间，<code>free_list</code>则用于维护<code>PyIntObject</code>可用的剩余内存空间。</p><ul><li><p>当<code>free_list</code>为<code>NULL</code>时，<code>Python</code>会重新<code>malloc</code>一个新的block出来。</p></li><li><p>当一个大整数对象的引用计数为0需要被回收时，其占用的内存空间并不会被回收，而是放到<code>free_list</code>数组中，供新创建的整数对象使用，从而减少内存创建、释放带来的开销。</p></li></ul><p>综上所述，可以解释变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>为什么是同一个对象。但是还不足以解释<code>c/f</code>以及在终端执行时<code>c/d</code>的结果。这就需要了解<strong>Python的解析模式</strong>——整体解释和逐行解释。</p><h3 id="整体解释与逐行解释"><a href="#整体解释与逐行解释" class="headerlink" title="整体解释与逐行解释"></a>整体解释与逐行解释</h3><p><strong>整体解释</strong>指的通过应用程序的方式来运行Python代码，而<strong>逐行解释</strong>是在交互式解释器中执行Python代码。在Python中，解析器的<strong>编译单元是一个函数</strong>（Python顶层代码也被当作一个函数来进行编译）。每个函数单独编译后会得到一个<code>PyFunctionObject</code>对象，该对象包含了字节码、常量池等信息。</p><p>每个<code>PyFunctionObject</code>都拥有一个独立的常量池，如果在同一个<code>PyFunctionObject</code>里创建了值相同的常量，那么这些常量只会在常量池里出现一份。</p><p>由此可知，问题中总共包含两个<code>PyFunctionObject</code>对象——由顶层函数和<code>foo</code>函数编译。顶层变量<code>c/d</code>和位于<code>foo</code>函数中的<code>f/g</code>分别位于两个不同的<code>PyFunctionObject</code>对象中，虽然值相同，但是内存地址不同。这就解释了<code>c/f</code>的运行结果。那为什么<code>a/e</code>两个变量是相同的对象了，那是因为小整数是全局解释器缓存的！</p><p>那么就剩一个问题了，为什么在交互式命令行终端<code>c/d</code>不是同一个对象了？</p><p>那是因为在交互式中，每输入一行语句就会立即执行，即<strong>编译单元是一行语句</strong>，每执行一行语句就会得到一个<code>PyFunctionObject</code>对象。注意，这里所说的“一行”是指的一次完整性输入。</p><p>综上所述，可以得到以下结论：</p><ul><li>整体解释是以函数为编译单元的，而交互式终端是以一行语句输入为编译单元，每个编译单元具有独立的常量池</li><li>小整数范围为<code>[-5, 257)</code>，缓存在全局解释器中，而大整数缓存在编译单元中</li></ul><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>修改<code>foo</code>函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(h=<span class="number">256</span>, i=<span class="number">257</span>)</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">'a is h'</span>, a <span class="keyword">is</span> h)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'c is i'</span>, c <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'f is i'</span>, f <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p> 运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span> h <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> i <span class="keyword">True</span></span><br><span class="line">f <span class="keyword">is</span> i <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> 你不知道的Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小整数 </tag>
            
            <tag> 大整数 </tag>
            
            <tag> 整数缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode31 下一个排列</title>
      <link href="/2018/05/04/n31-next-permutation/"/>
      <url>/2018/05/04/n31-next-permutation/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-permutation/description/" target="_blank" rel="noopener">LeetCode第31题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有数字序列n~1~n~2~n~3~…n~i~…n~m~，定义左边为高位，右边为低位。从低位向高位逐位比较，</p><p>如果n~i~ &lt;= n~i-1~，则继续向高位进位比较下一组（即i–）；</p><p>如果n~i~&gt;n~i-1~，则在n~i~ ~ n~m~之间寻找比n~i-1~大的最小数字，并与之交换。</p><p>最后对n~i~ ~ n~m~数字序列按从小到大进行排序，得到最终数字排列即为答案。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 从i -&gt; n中选择比nums[i-1]大的最小数字</span></span><br><span class="line">                j = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= i:</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &lt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    nums[i<span class="number">-1</span>], nums[j] = nums[j], nums[i<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 i -&gt; n 进行翻转，按从小到大排列</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; (len(nums)<span class="number">-1</span>-i) / <span class="number">2</span>:</span><br><span class="line">            nums[i+k], nums[len(nums)<span class="number">-1</span>-k] = nums[len(nums)<span class="number">-1</span>-k], nums[i+k]</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode30 与所有单词相关联的字串</title>
      <link href="/2018/05/03/n30-substring-with-concatenation-of-all-words/"/>
      <url>/2018/05/03/n30-substring-with-concatenation-of-all-words/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="noopener">LeetCode第30题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个字符串 <strong>s</strong> 和一些<strong><em>长度相同</em></strong>的单词 <strong>words。</strong>在 <strong>s</strong> 中找出可以恰好串联 <strong>words</strong> 中所有单词的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出: [0,9]</span><br><span class="line">解释: 从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先将<code>words</code>转换成字典<code>word_dict</code>，<code>key</code>为单词，<code>value</code>为单词出现的次数。以<code>words</code>所有单词总长度为窗口，截取字符串<code>s</code>，然后再将子串以单词长度进行分割。如果分割出的子串包含于<code>words</code>中，则<code>word_dict</code>计数相应的减1（计数等于0时，移除该单词），否则进行下一窗口截取。如果最后<code>word_dict</code>为空，则表示找到字符串可以用<code>words</code>所有单词完全匹配。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        word_num = len(words)</span><br><span class="line">        word_len = len(words[<span class="number">0</span>])</span><br><span class="line">        n_word_len = word_len * word_num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        d = word_dict.copy()</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p+n_word_len]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 每隔word_len进行截取，判断word_dict是否包含该子串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(word_num):</span><br><span class="line">                item = sub[i*word_len: (i+<span class="number">1</span>)*word_len]</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[item] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[item] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> d[item]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果word_dict为空，找到子串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">                res.append(p)</span><br><span class="line">                </span><br><span class="line">            d = word_dict.copy()</span><br><span class="line"> </span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>本题需要匹配的<code>words</code>列表单词长度是<strong>相同</strong>的，如果不相同了？</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barrfothefoobarman&quot;,</span><br><span class="line">  words = [&quot;fo&quot;,&quot;barr&quot;]</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 从索引 0 开始的子串为barrfo，可以用words所有单词完全匹配。</span><br></pre></td></tr></table></figure><p>基于以上思路，一种方法是修改子串的校验方法，使用逐字比较。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        n_word_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            n_word_len += len(word)</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p + n_word_len]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 逐字比较</span></span><br><span class="line">            <span class="keyword">if</span> self.word_cmp(sub, word_dict):</span><br><span class="line">                res.append(p)</span><br><span class="line"></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word_cmp</span><span class="params">(self, s, word_dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        d = word_dict.copy()</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s):</span><br><span class="line">            sub = s[<span class="number">0</span>:i]</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sub] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[sub] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> d[sub]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.word_cmp(s[i:], d):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode29 两数相除</title>
      <link href="/2018/05/01/n29-divide-two-integers/"/>
      <url>/2018/05/01/n29-divide-two-integers/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">LeetCode第29题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>除法是乘法的逆运算，假设 dividend / divisor = n，那么有dividend = divisor * n，亦可表示为n个数进行累加dividend = divisor + … + divisor。解答本题的基本思路即通过对除数进行累加直到超过被除数，累加的次数即为商。显然，这种方法运行效率不高，评测执行超时。那有没有什么方法在此算法基础上提升效率了，先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">求 12/2 的商，转换成加法，即：</span><br><span class="line">12 = 2 + 2 + 2 + 2 + 2 + 2</span><br><span class="line">共累加6次，即商为6。</span><br><span class="line"></span><br><span class="line">通过观察发现，每次都是累加同一个数字，能不能减少加法运算，快速逼近12？答案对除数进行移位操作。</span><br><span class="line"></span><br><span class="line">轮次  |     移位        |    商</span><br><span class="line">1        4 (2 &lt;&lt;= 1)       2 (1 &lt;&lt;= 1)</span><br><span class="line">2        8 (4 &lt;&lt;= 1)       4 (2 &lt;&lt;= 1)</span><br><span class="line">3        16 (8 &lt;&lt;= 1) 退出循环</span><br><span class="line"></span><br><span class="line">经过两轮循环，除数为8，商为4，余数为12 - 8 = 4。然后继续使用相同的方法计算4/2的商。</span><br><span class="line"></span><br><span class="line">轮次  |     移位    |    商</span><br><span class="line">1       4 (2 &lt;&lt;= 1)     2 (1 &lt;&lt;= 1)</span><br><span class="line">2       8 (4 &lt;&lt;= 1)  退出循环</span><br><span class="line"></span><br><span class="line">则12/2商为 4 + 2 = 6。通过此算法，共减少了3次加法运算。</span><br></pre></td></tr></table></figure><p>通过对除数进行移位操作可较少加法次数，从而提升算法执行效率。考虑到被除数或除数可能出现负数情况，可先计算商的正负情况，然后取被除数和除数的绝对值进行除法运算，最后再设置商的符号。</p><p>算法伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">令商result = 1 </span><br><span class="line">计算商是否为负数 neg = (dividend &lt; 0) ^ (divisor &lt; 0)</span><br><span class="line">取被除数、除数绝对值 dividend = abs(dividend), divisor = abs(divisor)</span><br><span class="line">假如 dividend &lt; divisor, 则返回0</span><br><span class="line">初始化count, n = 1, divisor</span><br><span class="line">while (n &lt;&lt; 1) &lt;= dividend</span><br><span class="line">   n &lt;&lt;= 1</span><br><span class="line">   count &lt;&lt;= 1</span><br><span class="line">result += count</span><br><span class="line">令dividend = dividend - n, 重复步骤4</span><br><span class="line">如果reg是负数, 则返回-result, 否则返回result (需考虑整数溢出情况)</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        neg  = (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>:  <span class="comment"># 当除数是1时，商直接设置为dividend</span></span><br><span class="line">            result = dividend</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="number">1</span></span><br><span class="line">            tmp = divisor</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;&lt; <span class="number">1</span>) &lt;= dividend:</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                result &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            result += self.divide(dividend - tmp, divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理正整数除法溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> result &gt;= <span class="number">2</span> ** <span class="number">31</span> <span class="keyword">and</span> <span class="keyword">not</span> neg:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -result <span class="keyword">if</span> neg <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><p>以上代码使用<code>Python3</code>编写，注意<code>Python3</code>没有<code>long</code>类型，<code>int</code>整形没有大小限制。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 除法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode25 k个一组翻转链表</title>
      <link href="/2018/04/20/n25-reverse-nodes-in-k-group/"/>
      <url>/2018/04/20/n25-reverse-nodes-in-k-group/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">LeetCode第25题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。<br>示例 :<br>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code><br>当 k = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code><br>当 k = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>说明:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">交换链表节点题</a>的延伸。本题解题思路可以采用递归法，先翻转前k个节点(如果链表小于k个节点，直接返回链表)，然后递归对其余节点进行翻转，最后将两者接上。<br>由于头节点可能会改变，所以在链表头部插入一个空节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        new_head.next = head</span><br><span class="line">        p = head</span><br><span class="line">        </span><br><span class="line">        node_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node_count &lt; k <span class="keyword">and</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            node_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node_count == k:</span><br><span class="line">    <span class="comment"># 对剩余的节点进行K-组翻转</span></span><br><span class="line">            current_node = self.reverseKGroup(p, k)</span><br><span class="line">    <span class="comment"># 对本次k节点进行翻转，并接上current_node</span></span><br><span class="line">            <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                temp = new_head.next</span><br><span class="line">                new_head.next = temp.next</span><br><span class="line">                temp.next = current_node</span><br><span class="line">                current_node = temp</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里需要将空节点指向current_node</span></span><br><span class="line">            new_head.next = current_node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode24 两两交换链表中的节点</title>
      <link href="/2018/04/15/n24-swap-nodes-in-pairs/"/>
      <url>/2018/04/15/n24-swap-nodes-in-pairs/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">LeetCode第24题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有P-&gt;A-&gt;B-&gt;C-&gt;…链表，交换A、B节点即把A.next指向C，B.next指向A，P.next指向B。算法步骤如下图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqdnfvn8p3j30nk0pgdgf.jpg" width="400"><br>在实现时，可以在头部添加一个空结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 插入一个空的节点，指向head</span></span><br><span class="line">        p = ListNode(<span class="number">0</span>)</span><br><span class="line">        p.next = head</span><br><span class="line">        head = p</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">and</span> p.next.next:</span><br><span class="line">            temp = p.next.next</span><br><span class="line">            p.next.next = p.next.next.next</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员密码</title>
      <link href="/2018/04/14/programmers-pwd/"/>
      <url>/2018/04/14/programmers-pwd/</url>
      <content type="html"><![CDATA[<p>这几天在<a href="https://www.v2ex.com/t/445123" target="_blank" rel="noopener">V2EX</a>上看到一个面向程序员的小游戏——在网页中找到一个隐藏的密码即可过关。游戏目前总共有两个level, level1有10道题，level2有5道题。游戏规则虽然简单，但是想要过关还是需要掌握不少知识，比如：’Chrome Developer Tools’工具使用、Baes64解码、图片隐写术等等。<br>游戏挺有意思的，在这里记录下，写者无心，读者请闭眼。</p><a id="more"></a><h2 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h2><p>进入游戏只有一个密码输入框，第一反应是打开开发者工具，寻找蛛丝马迹。通过细心观察，果然发现<code>Console</code>有信息打印，并且对源码进一步分析，游戏核心代码在<code>js/app/level.js</code>文件里。<code>level.js</code>粗略看下来，主要包含两部分重要信息：关卡通过对玩家输入的密码进行<code>md5</code>加密验证以及每个关卡执行的函数(存放在<code>LevelManager.prototype.levels</code>数组里)。<br>总体分析下来，得到的信息如下：<br>1）Console有信息提示<br>2）每个关卡的触发函数<br>3）md5加密</p><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1-0"></a>level1-0</h3><p>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p><h3 id="level1-1"><a href="#level1-1" class="headerlink" title="level1-1"></a>level1-1</h3><p>对<code>Console</code>打印的信息进行Base64解码 (为啥会想到Base64？因为字符最后的<code>=</code>号)<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m a programmer.</span><br></pre></td></tr></table></figure></p><h3 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h3><p>对<code>cGluZyB3d3cucHJvZ3JhbW1lcnBhc3N3b3JkLmNvbQ==</code>进行Base64解码，得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.programmerpassword.com</span><br></pre></td></tr></table></figure></p><p>进而在终端执行ping，获取ip地址<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47.104.152.148</span><br></pre></td></tr></table></figure></p><h3 id="level1-3"><a href="#level1-3" class="headerlink" title="level1-3"></a>level1-3</h3><p>本关卡没有在<code>Console</code>里打印信息，但是通过对关卡函数分析，本关卡在页面上插入了一段<code>html</code>代码，并且设置了透明样式。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码是123456</span><br></pre></td></tr></table></figure></p><h3 id="level1-4"><a href="#level1-4" class="headerlink" title="level1-4"></a>level1-4</h3><p><code>Console</code>打印了一串数字，使用<code>String.fromCharCode()</code>将十六进制整数转ascii码。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bug running</span><br></pre></td></tr></table></figure></p><h3 id="level1-5"><a href="#level1-5" class="headerlink" title="level1-5"></a>level1-5</h3><p>本关卡在页面上插入了一段<code>html</code>代码，只显示了一个<code>#</code>。开始以为是和<code>jQuery</code>的id选择器有关，结果答案却是<code>#</code>文字的RGB颜色值。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2f4584</span><br></pre></td></tr></table></figure></p><h3 id="level1-6"><a href="#level1-6" class="headerlink" title="level1-6"></a>level1-6</h3><p>图片的Base64编码，需要添加头部<code>data:image/jpeg;</code>。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">463700</span><br></pre></td></tr></table></figure></p><h3 id="level1-7"><a href="#level1-7" class="headerlink" title="level1-7"></a>level1-7</h3><p>访问<code>img.src</code>指定的url。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better to miss than to meet</span><br></pre></td></tr></table></figure></p><h3 id="level1-8"><a href="#level1-8" class="headerlink" title="level1-8"></a>level1-8</h3><p>在<code>Console</code>里输入<code>window.getPassword(&quot;H4sIAAAAAAAAC7MPcHq2ZWH987ndEfYA5w4bAwwAAAA=&quot;)</code><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25LTQWMP9Y</span><br></pre></td></tr></table></figure></p><h3 id="level1-9"><a href="#level1-9" class="headerlink" title="level1-9"></a>level1-9</h3><p>最坑爹的关卡，以为密码会隐藏在给出的PHP代码里，然而，然而，被坑了。。。把图片下载下来，然后使用十六进制编辑器打开图片，从jpg图片里可找到<code>cd /data/log/../www/; pwd</code>附加信息。<br>jpg隐写技巧原理可以参考这篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8JPEG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8Fpayload/" target="_blank" rel="noopener">隐写技巧-利用JPEG文件格式隐藏payload</a><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/www</span><br></pre></td></tr></table></figure></p><p>总结Level1关卡，整体难度其实并不高，只要善于使用谷歌开发者工具以及掌握Html&amp;Css、Base64编码、JPG隐写术等知识点就能轻松过关。</p><h2 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h2><p>Level2总共有5道题，虽然题目减少，但是难度较Level1提升了好几个档次。当然，坑更多…</p><h3 id="level2-0"><a href="#level2-0" class="headerlink" title="level2-0"></a>level2-0</h3><p>页面提示区显示了一段乱码，显然本关卡只需要解决乱码问题即可找到密码。<br>打开开发者工具，找到发起的ajax请求，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fqd3pnqa4xj30lq07aglt.jpg" alt="关卡请求"><br>通过分析可以发现，Html页面编码采用UTF-8，而ajax请求Http Response Content-Type Header设置了GBK编码类型，这就是导致乱码的原因。破解此题，只需如下操作：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd3urupjdj30lo0byaaj.jpg" alt="拷贝Curl请求"><br>右键拷贝curl请求，然后打开终端，执行curl请求：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fqd3xbjeqpj31kw02kdgb.jpg" alt="执行Curl请求"><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">春花秋月何时了</span><br></pre></td></tr></table></figure></p><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2-1"></a>level2-1</h3><p>本关卡提示信息是一张写有二进制的图片，显然第一反应是把图片上的二进制转成字符串，可以得到<code>error!</code>。经过试验，密码并不是<code>error!</code>。那么<code>error!</code>这几个字母是不是作者给我们的提示了，记过漫长时间的思考，终究没有找到答案。得放弃这个方向了，又是图片隐写术了？把图片下载下来，分析发现这是一张正常的图片，并没有添加额外的附加信息。又经过一段时间的思考，突然想到，是不是密码存放在图片属性里。立马右键图片，查看属性内容，果然图片添加了“备注”，心里一乐。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd4mgsottj30bm0i0jrr.jpg" alt=""><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCFHJJUKLI</span><br></pre></td></tr></table></figure></p><p>上文里其实介绍过JPG隐写术，本关卡也是隐写术的一种，使用<a href="http://www.impulseadventure.com/photo/jpeg-snoop.html" target="_blank" rel="noopener">JPEGsnoop</a>工具打开图片亦可查找到备注信息。</p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 程序员密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员密码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode23 合并K个有序链表</title>
      <link href="/2018/04/13/n23-merge-k-sorted-lists/"/>
      <url>/2018/04/13/n23-merge-k-sorted-lists/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第23题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>合并k个有序链表，返回合并后的排序链表。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第21题-合并两个有序链表</a>的扩展。所以，一种思路是采用两两合并的算法进行合并，但是算法复杂度较高。<br>另外一种思路是采用最小堆法，算法步骤如下：</p><ol><li>将k个链表的头结点放入最小堆；</li><li>从堆中取出最小元素并插入结果链表中;</li><li>如果取出的最小元素还有下一个元素，将其放入最小堆中;</li><li>执行步骤<code>2</code>，直到堆中元素全部被取出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化返回的链表</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化最小堆：取链表的头节点</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            n = lists[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 注意ListNode对象不能应用&lt;或者&gt;运算符，所以引入链表下标。通过(n.val, i)即可完成元素比较。</span></span><br><span class="line">            heapq.heappush(heap, (n.val, i, n)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次取出堆中最小的元素，插入到返回链表中，然后再将下一个节点插入最小堆中</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            _, i, min_node = heapq.heappop(heap)</span><br><span class="line">            p.next = min_node</span><br><span class="line">            p = min_node</span><br><span class="line">            <span class="keyword">if</span> min_node.next:</span><br><span class="line">                heapq.heappush(heap, (min_node.next.val, i, min_node.next))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
