<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>subprocess-call, check_call, check_output, Popen</title>
      <link href="/2018/07/23/py-subprocess/"/>
      <url>/2018/07/23/py-subprocess/</url>
      <content type="html"><![CDATA[<p>在Python中，我们通过使用标准库中的subprocess模块来fork一个子进程，并运行一个外部的程序（类似于在linux中fork一个子进程，然后在子进程中exec另外一个程序）。 </p><a id="more"></a><p>这一模块中提供了多种方法：</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.call(args, *, stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><ol><li>参数args描述了子进程中需要执行的命令；</li><li><strong>父进程会等待子进程的结束</strong>，并获得call函数的返回值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">cmd = [<span class="string">'ls'</span>, <span class="string">'-l];</span></span><br><span class="line"><span class="string">ret = subprocess.call(cmd)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cmd = ['</span>exit <span class="number">1</span><span class="string">'];</span></span><br><span class="line"><span class="string">ret = subprocess.call(cmd, shell=True);</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如果子进程不需要进行交互,就可以使用该函数来创建</li></ol><h3 id="check-call"><a href="#check-call" class="headerlink" title="check_call"></a>check_call</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.check_call(args, *, stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><ol><li>check_call()与call()唯一的区别在于返回值。如果args执行之后的返回值为0，那么check_all返回0；如果返回值不为0，那么将raise出来一个CalledProcessError </li></ol><h3 id="check-output"><a href="#check-output" class="headerlink" title="check_output"></a>check_output</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.check_output(args, *, stdin=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, shell=<span class="keyword">False</span>, universal_newlines=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><ol><li>子进程执行args中的命令，并将其输出形成字符串返回</li><li>如果返回值非零，那么将raise一个CalledProcessError。这一对象实例中有returncode属性以及output属性（args命令的output）</li></ol><h3 id="Popen"><a href="#Popen" class="headerlink" title="Popen"></a>Popen</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(args, bufsize=<span class="number">0</span>, executable=<span class="keyword">None</span>, stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, preexec_fn=<span class="keyword">None</span>, close_fds=<span class="keyword">False</span>, shell=<span class="keyword">False</span>, cwd=<span class="keyword">None</span>, env=<span class="keyword">None</span>, universal_newlines=<span class="keyword">False</span>, startupinfo=<span class="keyword">None</span>, creationflags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol><li><p>Popen对象创建后，<strong>主程序不会自动等待子进程完成</strong>。我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block) </p></li><li><p>Popen中封装的其他函数 ：</p><blockquote><ol><li>Popen.<strong>poll</strong>()：检查子进程的状态，查看子进程是否结束</li><li>Popen.<strong>wait</strong>()：等待子进程的结束</li><li>Popen.<strong>communicate</strong>(input=None)：与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</li><li>Popen.<strong>send_signal</strong>(signal)：向子进程发送信号</li><li>Popen.<strong>terminate</strong>()：停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程</li><li>Popen.<strong>kill</strong>()：杀死子进程</li><li>Popen.<strong>stdin</strong>：如果在创建Popen对象时，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于向子进程发送指令；否则返回None</li><li>Popen.<strong>stdout</strong>：如果在创建Popen对象时，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于向子进程发送指令；否则返回None</li><li>Popen.<strong>stderr</strong>：如果在创建Popen对象时，参数stderr被设置为PIPE，Popen.stderr将返回一个文件对象用于向子进程发送指令；否则返回None</li><li>Popen.<strong>pid</strong>：获取子进程的进程ID</li><li>Popen.<strong>returncode</strong>：获取进程的返回值。如果进程还没有结束，返回None</li></ol></blockquote></li></ol><p>需要注意的是，在使用<code>Popen.wait()</code>方法等待子程序完成时，如果<code>stdout</code>或者<code>stderr</code>设置了<code>PIPE</code>，那么当子进程的输出超过操作系统的pipe size时，会<a href="https://docs.python.org/release/2.7.3/library/subprocess.html#subprocess.Popen.wait" target="_blank" rel="noopener">导致死锁</a>的情况。所以官方建议使用<code>Popen.communicate()</code>方法，因为子进程的输出是直接写入系统内存空间，一般不会超出内存上限。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blog.csdn.net/yuchen1986/article/details/22059873" target="_blank" rel="noopener">subprocess模块学习-call, checkall, check_output, Popen</a></li><li><a href="https://blog.csdn.net/carolzhang8406/article/details/22286913" target="_blank" rel="noopener">Popen communicate() 和wait()使用上的区别</a></li></ol>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> subprocess </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python有GIL，为什么还需要线程同步</title>
      <link href="/2018/07/11/py-GIL-multithreading-lock/"/>
      <url>/2018/07/11/py-GIL-multithreading-lock/</url>
      <content type="html"><![CDATA[<p>GIL的作用是，对于一个解释器，只能有一个thread在执行bytecode。所以任何时刻只有一条bytecode在被一个thread执行。Python的多线程并不是严格意义上的并行执行，GIL在bytecode层面上保证了thread safe，但是python多线程包里依然提供了加锁机制，这是为何？</p><a id="more"></a><p>假设有个操作，比如<code>x += 1</code>，这个操作需要多个bytecodes操作，在执行这个操作的多条bytecodes期间，可能会发生thread切换，这样就出现了线程竞争的情况。</p><p>比如以下案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">global</span> num</span><br><span class="line"><span class="meta">... </span>  num += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(f)</span><br><span class="line">  <span class="number">3</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (num)</span><br><span class="line">              <span class="number">3</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">6</span> INPLACE_ADD</span><br><span class="line">              <span class="number">7</span> STORE_GLOBAL             <span class="number">0</span> (num)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (<span class="keyword">None</span>)</span><br><span class="line">             <span class="number">13</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>分析以上可知，要实现<code>num += 1</code>操作总共使用了4条bytecodes。GIL并不能保证此操作的原子性，在<code>LOAD_GLOBAL</code>和<code>STORE_GLOBAL</code>执行之间，有可能发生线程切换。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIL </tag>
            
            <tag> multithreading </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode39 组合总和</title>
      <link href="/2018/06/15/n39-combination-sum/"/>
      <url>/2018/06/15/n39-combination-sum/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum/description/" target="_blank" rel="noopener">LeetCode 第39题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归回溯法：</p><ol><li>遍历<code>candidates</code>，计算<code>target</code>与每个数字<code>num</code>的余数</li><li>如果余数等于0，则将<code>num</code>添加到结果列表</li><li>否则，令<code>target</code>等于余数，跳转到第一步，从剩余数字（包括<code>num</code>）中查找<code>target</code>组合</li><li>如果<code>target</code>小于零，终止递归</li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)):</span><br><span class="line">            num = candidates[i]</span><br><span class="line">            r = target - num</span><br><span class="line">            <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">                result.append([num])</span><br><span class="line">            combs = self.combinationSum(candidates[i:], r)</span><br><span class="line">            <span class="keyword">if</span> combs:</span><br><span class="line">                <span class="keyword">for</span> comb <span class="keyword">in</span> combs:</span><br><span class="line">                    comb.insert(<span class="number">0</span>, num)</span><br><span class="line">                    result.append(comb)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>本题可以先对<code>candidates</code>排序，当余数<code>r</code>小于零时，终止后面数字的遍历，从而降低时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 对candidates进行排序</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="keyword">return</span> self.__combinationSum(candidates, target)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)):</span><br><span class="line">            num = candidates[i]</span><br><span class="line">            r = target - num</span><br><span class="line">            <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">                result.append([num])</span><br><span class="line">            <span class="comment"># 如果余数小于零，后续的数字都没必要进行遍历</span></span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            combs = self.combinationSum(candidates[i:], r)</span><br><span class="line">            <span class="keyword">if</span> combs:</span><br><span class="line">                <span class="keyword">for</span> comb <span class="keyword">in</span> combs:</span><br><span class="line">                    comb.insert(<span class="number">0</span>, num)</span><br><span class="line">                    result.append(comb)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 求和 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode36 有效的数独</title>
      <link href="/2018/06/04/n36-valid-sudoku/"/>
      <url>/2018/06/04/n36-valid-sudoku/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-sudoku/description/" target="_blank" rel="noopener">LeetCode 第36题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br><span class="line">解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</span><br><span class="line">     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用字典标识每个数字的行、列以及宫，如果出现重复的数字，即表示数独无效。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_d = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                num = board[row][col]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (num, <span class="string">'r'</span>, row) <span class="keyword">in</span> num_d:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> (num, <span class="string">'c'</span>, col) <span class="keyword">in</span> num_d:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> (num, row // <span class="number">3</span>, col // <span class="number">3</span>) <span class="keyword">in</span> num_d:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                </span><br><span class="line">                num_d[(num, <span class="string">'r'</span>, row)] = <span class="number">1</span>  <span class="comment"># 所在行</span></span><br><span class="line">                num_d[(num, <span class="string">'c'</span>, col)] = <span class="number">1</span>  <span class="comment"># 所在列</span></span><br><span class="line">                num_d[(num, row // <span class="number">3</span>, col // <span class="number">3</span>)] = <span class="number">1</span>  <span class="comment"># 所在宫</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数独 </tag>
            
            <tag> 字典 </tag>
            
            <tag> 哈希 Hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode375 猜数字大小 II</title>
      <link href="/2018/06/02/n375-guess-number-higher-or-lower-ii/"/>
      <url>/2018/06/02/n375-guess-number-higher-or-lower-ii/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/description/" target="_blank" rel="noopener">LeetCode第375题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 <strong>1</strong> 到 <strong>n</strong> 之间选择一个数字，你来猜我选了哪个数字。</p><p>每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。</p><p>然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 10, 我选择了8.</span><br><span class="line"></span><br><span class="line">第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。</span><br><span class="line">第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。</span><br><span class="line">第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。</span><br><span class="line"></span><br><span class="line">游戏结束。8 就是我选的数字。</span><br><span class="line"></span><br><span class="line">你最终要支付 5 + 7 + 9 = 21 块钱。</span><br></pre></td></tr></table></figure><p>给定一个 <strong>n ≥ 1，</strong>计算你至少需要拥有多少现金才能确保你能赢得这个游戏。</p><p><strong>致谢:</strong></p><p>特别感谢 <a href="https://leetcode.com/agave/" target="_blank" rel="noopener">@agave</a> 和 <a href="https://leetcode.com/stefanpochmann/" target="_blank" rel="noopener">@StefanPochmann</a> 添加了这道题目，并且提供了所有测试用例。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>解答本题时，第一思路是采用快速查找算法，但是步长少并意味着支付的金额最少。那如何解决本题了？当没有思路的时候，最笨的方法就是最好的方法，列举一些数字，看看其中有没有什么规律：</p><ul><li>当<code>n = 1</code>时，显然<code>cost = 0</code></li><li>当<code>n = 2</code>时，即<code>[1, 2]</code>，显然<code>cost=1</code></li><li>当<code>n = 3</code>时，即<code>[1, 2, 3]</code>，只需要猜中间数字<code>2</code>就能知道结果，因为比<code>2</code>大的只有一个，比<code>2</code>小的也只有一个，所以<code>cost=2</code></li><li>当<code>n = 4</code>时，即<code>[1, 2, 3, 4]</code> 。四个数字显然不能一眼看出最少<code>cost</code>，那就一个一个来计算吧：<ul><li>如果先猜<code>1</code>，如果猜中，则<code>cost=1</code>，否则数字在<code>[2-4]</code>之间，这时需花费<code>cost = 1 +  Cost(2, 4) = 1 + 3 = 4</code>。这时，应该取<code>cost=4</code>，为什么了，因为如果你要赢得比赛，就必须至少要带<code>￥4</code>，所以取大</li><li>如果先猜<code>2</code>，则<code>cost = 2 + Cost(3,4) = 2 + 3 = 5</code></li><li>如果先猜<code>3</code>，则<code>cost = 3 + Cost(1,2) = 3 + 1 = 4</code></li><li>如果先猜<code>4</code>，则<code>cost = 4 + Cost(1,3) = 4 + 2 = 6</code> </li><li>==综上所列==，当有4个数字时，至少要带<code>￥4</code>（为啥？因为按照上面的方案，至少要带够<code>￥4</code>元才有可能赢得这个游戏呀！）。至此已经可以看出，这是一道求局部最大值，全局最小值的问题，</li></ul></li><li>当<code>n = 5</code>时，即<code>[1, 2, 3, 4, 5]</code>，同样可以挨个计算每个数字，最终得到最小cost</li></ul><p>综上所述，当给定数字<strong>n</strong>时，可以从<code>1</code>开始，计算全部至少花费情况，最后取最小花费，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算[i, j]区间最小花费</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost</span><span class="params">(i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> j &lt;= i:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> j - i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">if</span> j - i == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始最大整数</span></span><br><span class="line">    global_min = INT_MAX</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># k + max(左边最小花费，右边最小花费)</span></span><br><span class="line">local_max = k + max(min_cost(i, k<span class="number">-1</span>), min_cost(k+<span class="number">1</span>, j))</span><br><span class="line">        global_min = min(local_max, global_min)</span><br><span class="line">    <span class="keyword">return</span> global_min</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定n</span></span><br><span class="line">min_cost(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure><p>至此，本题可以采用递归的方法解决，但是算法复杂度较高，不能通过测试。通过观察发现，在递归计算过程中，有很多区间会被重复计算。一种优化策略是保存计算结果，相同计算时直接从缓存中读取。</p><p>另外一种解题方法是采用动态规划实现。比如当<code>n=5</code>时，</p><ol><li><p>初始化一个<code>n+1</code>维<code>dp</code>数组</p><p><img width="400" src="https://ws1.sinaimg.cn/large/006tNc79ly1frx8rjoupnj30y00hk0t9.jpg"></p></li><li><p>令<code>i</code> in <code>range(2, 6)</code>，<code>j</code> in <code>range(i-1, 0, -1)</code>， 计算区间<code>[j, i]</code>的最小花费</p><ul><li><p>当i = 2时</p><ul><li>当j = 1 <ul><li>当k = 1，<code>cost = 1</code></li><li><code>dp[1][2]=1</code></li></ul></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frx94tmfzwj30yq0hu74u.jpg" width="420"></p></li><li><p>当i = 3时</p><ul><li><p>当j = 2</p><ul><li>当k = 2，<code>cost = 2</code></li><li><code>dp[2][3]=2</code></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frx9ajln1cj30y80hu0ta.jpg" width="450"></p></li><li><p>当j = 1</p><ul><li>当k = 1，<code>cost = 1 + dp[2][3] =3</code></li><li>当k = 2，<code>cost = 2 + max(dp[1][1], dp[3][3]) = 2</code></li><li><code>dp[1][3] = 2</code></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1frx9g885abj30z00iedgf.jpg" width="440"></p></li></ul></li><li><p>当i = 4时</p><ul><li><p>当j = 3</p><ul><li>当k = 3， <code>cost = 3</code></li><li><code>dp[3][4] = 3</code></li></ul></li><li><p>当j = 2</p><ul><li>当k = 2，<code>cost = 2 + dp[3][4] = 5</code></li><li>当k = 3，<code>cost = 3 + max(dp[2][2], dp[4][4]) = 3</code></li><li><code>dp[2][4] = 3</code></li></ul></li><li><p>当j = 1</p><ul><li>当k = 1， <code>cost = 1 + dp[2][4] = 4</code></li><li>当k = 2，<code>cost = 2 + max(dp[1][1], dp[3][4]) = 5</code></li><li>当k = 3，<code>cost = 3 + max(dp[1][2], dp[4][4]) = 4</code></li><li><code>dp[1][4] = 4</code></li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1frx9ovjemgj30yg0humxr.jpg" width="440"></p></li></ul></li><li><p>当i = 5时</p><ul><li>当j = 4<ul><li>当k = 4， <code>dp[4][5]=4</code></li></ul></li><li>当j = 3<ul><li>当k = [3, 4]，<code>dp[3][5] = 4</code></li></ul></li><li>当j = 2<ul><li>当k = [2, 3, 4]，<code>dp[2][5] = 6</code></li></ul></li><li>当j = 1<ul><li>当k = [1, 2, 3, 4]，<code>dp[1][5] = 4</code></li></ul></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frx9ve6svtj30y40h4t9b.jpg" width="460"></p></li></ul></li><li><p><code>dp[1][5]即为最小花费金额</code></p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMoneyAmount</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                global_min = sys.maxsize</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j, i):</span><br><span class="line">                    local_max = k + max(dp[j][k<span class="number">-1</span>], dp[k+<span class="number">1</span>][i])</span><br><span class="line">                    global_min = min(local_max, global_min)</span><br><span class="line">                dp[j][i] = global_min</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 猜数字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scala 下划线的用途</title>
      <link href="/2018/05/30/scala-underscore/"/>
      <url>/2018/05/30/scala-underscore/</url>
      <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://my.oschina.net/joymufeng/blog/863823" target="_blank" rel="noopener">Scala基础 - 下划线使用指南</a> <a href="https://my.oschina.net/joymufeng/home" target="_blank" rel="noopener">@joymufeng</a></p></blockquote><a id="more"></a><h3 id="用户替换Java的等价语法"><a href="#用户替换Java的等价语法" class="headerlink" title="用户替换Java的等价语法"></a>用户替换Java的等价语法</h3><h4 id="导入通配符"><a href="#导入通配符" class="headerlink" title="导入通配符"></a>导入通配符</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala</span></span><br><span class="line"><span class="keyword">import</span> java.util._</span><br></pre></td></tr></table></figure><p><code>*</code>在Scala中是合法的方法名，所以导入包时要使用<code>_</code>代替。</p><h4 id="类成员默认值"><a href="#类成员默认值" class="headerlink" title="类成员默认值"></a>类成员默认值</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="comment">// String类型的默认值为null</span></span><br><span class="line">    <span class="keyword">var</span> s: <span class="type">String</span> = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动设置类成员变脸的默认值。</p><p>注：该语法只适合于类成员，不适用于局部变量。</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>Java声明可变参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArgs</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object elem: args)&#123;</span><br><span class="line">        System.out.println(elem + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入两个参数</span></span><br><span class="line">printArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//也可以传入一个数组</span></span><br><span class="line">printArgs(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;);</span><br></pre></td></tr></table></figure><p>在Java中可以直接将数组传给<code>printArgs</code>方法，但在Scala中需要明确的指定是想将集合作为一个独立参数传进去，还是想将集合的元素传进去。如果是后者，则要借助下划线：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printArgs(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>): _*)</span><br></pre></td></tr></table></figure><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><p>Java的泛型系统有一个通配符类型，例如List&lt;?&gt;，任意的List<t>类型都是List&lt;?&gt;的子类型，如果我们想编写一个可以打印所有List类型元素的方法，可以如下声明： </t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object elem: list)&#123;</span><br><span class="line">        System.out.println(elem + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Scala版本为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printList</span></span>(list: <span class="type">List</span>[_]): <span class="type">Unit</span> =&#123;</span><br><span class="line">   list.foreach(elem =&gt; println(elem + <span class="string">" "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><h4 id="默认匹配"><a href="#默认匹配" class="headerlink" title="默认匹配"></a>默认匹配</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str <span class="keyword">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"1"</span> =&gt; println(<span class="string">"match 1"</span>)</span><br><span class="line">    <span class="keyword">case</span> _   =&gt; println(<span class="string">"match default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配集合元素"><a href="#匹配集合元素" class="headerlink" title="匹配集合元素"></a>匹配集合元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配以0开头，长度为三的列表</span></span><br><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _, _) =&gt; println(<span class="string">"found it"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配以0开头，长度任意的列表</span></span><br><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _*) =&gt; println(<span class="string">"found it"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配元组元素</span></span><br><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; println(<span class="string">"found it"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将首元素赋值给head变量</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">List</span>(head, _*) = <span class="type">List</span>(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure><h3 id="Scala特有语法"><a href="#Scala特有语法" class="headerlink" title="Scala特有语法"></a>Scala特有语法</h3><h4 id="访问Tuple元素"><a href="#访问Tuple元素" class="headerlink" title="访问Tuple元素"></a>访问Tuple元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(t._1, t._2, t._3)</span><br></pre></td></tr></table></figure><h4 id="简写函数字面量（function-literal）"><a href="#简写函数字面量（function-literal）" class="headerlink" title="简写函数字面量（function literal）"></a>简写函数字面量（function literal）</h4><p>如果函数的参数在函数体内只出现一次，则可以使用下划线代替： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1 = (_: <span class="type">Int</span>) + (_: <span class="type">Int</span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> f2 = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br><span class="line"></span><br><span class="line">list.foreach(println(_))</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">list.foreach(e =&gt; println(e))</span><br><span class="line"></span><br><span class="line">list.filter(_ &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">list.filter(x =&gt; x &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="定义一元操作符"><a href="#定义一元操作符" class="headerlink" title="定义一元操作符"></a>定义一元操作符</h4><p>在Scala中，操作符其实就是方法，例如<code>1 + 1</code>等价于<code>1.+(1)</code>，利用下划线我们可以定义自己的左置操作符，例如Scala中的负数就是用左置操作符实现的： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="number">2.</span>unary_-</span><br></pre></td></tr></table></figure><h4 id="定义赋值操作符"><a href="#定义赋值操作符" class="headerlink" title="定义赋值操作符"></a>定义赋值操作符</h4><p>通过下划线实现赋值操作符，从而可以精确地控制赋值过程： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= &#123; <span class="string">"foo"</span> &#125;</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">name_=</span></span>(str: <span class="type">String</span>) &#123;</span><br><span class="line">     println(<span class="string">"set name "</span> + str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Foo</span>()</span><br><span class="line">m.name = <span class="string">"Foo"</span> <span class="comment">//等价于: m.name_=("Foo")</span></span><br></pre></td></tr></table></figure><h4 id="定义部分应用函数（partially-applied-function）"><a href="#定义部分应用函数（partially-applied-function）" class="headerlink" title="定义部分应用函数（partially applied function）"></a>定义部分应用函数（partially applied function）</h4><p>可以为某个函数只提供部分参数进行调用，返回的结果是一个新的函数，即部分应用函数。因为只提供了部分参数，所以部分应用函数也因此而得名。 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>) = a + b + c</span><br><span class="line"><span class="keyword">val</span> b = sum(<span class="number">1</span>, _: <span class="type">Int</span>, <span class="number">3</span>)</span><br><span class="line">b: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line">b(<span class="number">2</span>) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h4 id="将方法转换成函数"><a href="#将方法转换成函数" class="headerlink" title="将方法转换成函数"></a>将方法转换成函数</h4><p>Scala中方法和函数是两个不同的概念，方法无法作为参数进行传递，也无法赋值给变量，但是函数是可以的。在Scala中，利用下划线可以将方法转换成函数： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将println方法转换成函数，并赋值给p</span></span><br><span class="line"><span class="keyword">val</span> p = println _  </span><br><span class="line"><span class="comment">//p: (Any) =&gt; Unit</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>方法和函数的不同：<ul><li>方法是一个以<code>def</code>开头的带有参数列表的一个逻辑操作块，比如object或者class的成员方法</li><li>函数是一个赋值给一个变量（或者常量）的匿名方法，并且通过<code>=&gt;</code>转换符号跟上逻辑代码块的一个表达式</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> underscore </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode32 最长有效括号</title>
      <link href="/2018/05/25/n32-longest-valid-parentheses/"/>
      <url>/2018/05/25/n32-longest-valid-parentheses/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/description/" target="_blank" rel="noopener">LeetCode第32题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题的一种思路是使用栈，栈中元素保存<code>[字符，最大长度]</code></p><ol><li><p>初始化栈<code>stack</code>和最大长度<code>max_len</code></p></li><li><p>遍历字符串</p></li><li><p>如果当前字符是<code>)</code>，且栈顶元素<code>stack[-1] = [&#39;(&#39;, length]</code>，那么：</p><ul><li><p>当前匹配长度 = <code>length + 2</code></p></li><li><p>弹出栈顶元素</p></li><li><code>stack[-1][1] += 当前匹配长度</code></li><li><code>max_len = max(stack[-1][1], max_len)</code></li></ul></li><li><p>否则，将<code>[&#39;x&#39;, 0]</code>压栈</p></li><li><p>返回<code>max_len</code>即为最长有效括号</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        stack, max_len = [[<span class="string">''</span>, <span class="number">0</span>]], <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ord(c) == ord(stack[<span class="number">-1</span>][<span class="number">0</span>]) + <span class="number">1</span>:</span><br><span class="line">                count = stack[<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                stack.pop()</span><br><span class="line">                stack[<span class="number">-1</span>][<span class="number">1</span>] += count</span><br><span class="line">                max_len = max(stack[<span class="number">-1</span>][<span class="number">1</span>], max_len)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append([c, <span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p>另外一种解题思路是采用栈和动态规划：</p><ol><li>定义<code>start</code>变量记录合法括号串的起始位置</li><li>遍历字符串</li><li>如果遇到<code>(</code>，则将当前下标压入栈</li><li>如果遇到<code>)</code>，则有两种情况：<ul><li>如果当前栈为空，则将下一个坐标位置记录到<code>start</code></li><li>如果当前栈不为空，则将栈顶元素取出<ul><li>若此时栈为空，最长值=<code>max(最长值, 当前下标 - start + 1)</code></li><li>否则最长值=<code>max(最长值, 当前下标 - 栈顶元素值)</code></li></ul></li></ul></li></ol><p>代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, res, start = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            e = s[i]</span><br><span class="line">            <span class="keyword">if</span> e == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                    start = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    res = max(res, i - start + <span class="number">1</span>) <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">else</span> max(res, i - stack[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>此算法比上面的在空间复杂度上更优。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图分析总结</title>
      <link href="/2018/05/25/graph-analysis/"/>
      <url>/2018/05/25/graph-analysis/</url>
      <content type="html"><![CDATA[<p>图分析是知识图谱（Knowledge Graph）图结构消费的重要组成部分，基于图分析算法的应用近年来层出不穷，比如：Palantir利用关联分析指导复杂战场环境下的军事行动、天眼查发现企业关联关系、拓尔思水晶球、宜信金融反欺诈等等。</p><p>本文首先对图分析算法进行归纳总结，后期将结合现有的工具，详细介绍图分析每个算法的实现以及应用案例。</p><a id="more"></a><h3 id="图度量"><a href="#图度量" class="headerlink" title="图度量"></a>图度量</h3><h4 id="节点度量"><a href="#节点度量" class="headerlink" title="节点度量"></a>节点度量</h4><table><thead><tr><th>节点度量</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>度中心性 <br>Degree centrality</td><td>与节点连接的数据量，如果是有向图，则分为入度和出度</td><td><a href="https://www.cl.cam.ac.uk/teaching/1213/L109/stna-lecture3.pdf" target="_blank" rel="noopener">lecture</a></td></tr><tr><td>介数中心性 <br>Betweenness centrality</td><td>指其它两个节点的所有最短路径都经过这个节点，<br>则这些所有最短路径数即为此节点的介数中心性。<br>可用来鉴别网络中的“信息中间人”或者聚类后的联结点</td><td></td></tr><tr><td>紧密中心性 <br>Closeness centrality</td><td>指节点到网络中所有其他节点的平均距离的倒数</td><td><a href="http://link.springer.com/article/10.1007%2FBF02289527?LI=true" target="_blank" rel="noopener">Sabidussi</a></td></tr><tr><td>特征向量中心性 <br>Eigenvector centrality</td><td>指节点在网络中的重要程度，比PageRank更泛</td><td><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.131.8175&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Newman</a></td></tr><tr><td>HITS <br>Hpyerlink - Induced Topic Search</td><td>使用<code>(Hub, Authority)</code>描述节点重要性<br>- Hub 枢纽性，指包含了很多指向高质量<code>Authority</code>页<br>面链接的页面，如<code>hao123</code><br>- Authority权威性，指与某个领域或者某个话题相关的<br>高质量网页，比如视频领域<code>youtobe</code><br><br>- 两个假设：<br><br>1. 一个好的<code>Authority</code>会被很多好的<code>Hub</code>指向<br>2. 一个好的<code>Hub</code>页面会指向很多好的<code>Authority</code></td><td><a href="http://www.csee.umbc.edu/~kolari1/Mining/papers/ft_gateway.cfm.pdf" target="_blank" rel="noopener">Kleinberg</a></td></tr><tr><td>Neighbordhood Connectivity</td><td>给定节点的邻居的平均连通性（度中心性）</td><td><a href="http://science.sciencemag.org/content/296/5569/910.full" target="_blank" rel="noopener">Maslov</a></td></tr><tr><td>Vertex Embeddedness</td><td>给定节点的邻居的平均嵌入度</td><td><a href="https://www3.nd.edu/~nchawla/papers/kdd14b.pdf" target="_blank" rel="noopener">Dong</a></td></tr><tr><td>Local Clustering Coefficient</td><td>给定节点的邻居的现有连接数量除以邻居节点集合全部<br>可能的连接数量，用于衡量邻居节点的紧密程度</td><td><a href="http://www.nature.com/nature/journal/v393/n6684/full/393440a0.html" target="_blank" rel="noopener">Watts</a></td></tr></tbody></table><h4 id="边度量"><a href="#边度量" class="headerlink" title="边度量"></a>边度量</h4><table><thead><tr><th>边度量</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>Adamic/Adar</td><td>给定两个顶点的公共邻居中心度的倒数和</td><td><a href="http://link.springer.com/article/10.1140/epjb/e2009-00335-8" target="_blank" rel="noopener">Adamic</a></td></tr><tr><td>Common Neighbours</td><td>给定两个顶点的公共邻居节点数量</td><td><a href="http://journals.aps.org/pre/pdf/10.1103/PhysRevE.64.025102" target="_blank" rel="noopener">Newman</a></td></tr></tbody></table><h4 id="图度量-1"><a href="#图度量-1" class="headerlink" title="图度量"></a>图度量</h4><table><thead><tr><th>图度量</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>Freeman’s network centrality</td><td>描述网络中节点度中心性的不均匀程度</td><td><a href="http://leonidzhukov.ru/hse/2013/socialnetworks/papers/freeman79-centrality.pdf" target="_blank" rel="noopener">Freeman</a></td></tr><tr><td>Modularity</td><td>网络分成社区（模块、集群）的强度</td><td><a href="https://www.cs.umd.edu/class/fall2009/cmsc858l/lecs/Lec10-modularity.pdf" target="_blank" rel="noopener">lecture</a><br><a href="http://arxiv.org/pdf/cond-mat/0308217.pdf" target="_blank" rel="noopener">Newman</a></td></tr></tbody></table><h3 id="社区发现"><a href="#社区发现" class="headerlink" title="社区发现"></a>社区发现</h3><blockquote><p>同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏</p></blockquote><p>社区发现主要面向非重叠社团发现和重叠社团发现两类问题。所谓重叠性，是指单个顶点并非仅仅属于一个社团，而是可以属于多个社团。社团与社团由这些有重叠归属的顶点相连。</p><ul><li>非重叠社团发现算法</li></ul><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>基于模块度优化的社团发现</td><td>优化模块度Q值的算法</td><td>- 采用聚合思想 <a href="https://arxiv.org/pdf/cond-mat/0309508.pdf" target="_blank" rel="noopener">FN</a> <a href="https://www.cs.unm.edu/~treport/tr/05-02/local_communities.pdf" target="_blank" rel="noopener">CNM</a> <a href="http://www.zora.uzh.ch/id/eprint/4767/3/Schuetz_PR_Multistep_2008FullV.pdf" target="_blank" rel="noopener">MSGMV</a> <br>- 采用分裂思想 <a href="http://www.pnas.org/content/pnas/99/12/7821.full.pdf" target="_blank" rel="noopener">GN</a> <a href="http://www.pnas.org/content/pnas/103/23/8577.full.pdf" target="_blank" rel="noopener">谱方法</a><br>- 直接寻优法 <a href="https://pdfs.semanticscholar.org/8b69/abb769aace58bc122ce16beeb551e9dcfebb.pdf" target="_blank" rel="noopener">EO</a></td></tr><tr><td>基于谱分析的社团发现</td><td>将节点对应的矩阵特征分量看<br>成空间坐标，将网络节点映射<br>到多维向量空间，运用传统的<br>聚类算法将他们聚集成社团</td><td></td></tr><tr><td>基于信息论的社团发现</td><td>模拟退火优化算法和随机游走</td><td><a href="http://octavia.zoology.washington.edu/publications/rosvallandbergstrom07.pdf" target="_blank" rel="noopener">Rosvall</a> <a href="http://www.mapequation.org/assets/publications/RosvallBergstromPNAS2008Full.pdf" target="_blank" rel="noopener">Random Walks</a></td></tr><tr><td>基于标签传播的社团发现</td><td>网络的边很多时候代表信息的传播</td><td><a href="https://arxiv.org/pdf/0709.2938.pdf" target="_blank" rel="noopener">LPA</a></td></tr></tbody></table><ul><li>重叠社团发现算法</li></ul><table><thead><tr><th>方法</th><th>描述</th><th>资料</th></tr></thead><tbody><tr><td>基于团渗透改进的社团发现</td><td>以团为基本单元来发现重叠，这对于很多真<br>实网络尤其是稀疏网络而言，限制条件过于严<br>格，只能发现少量的重叠社团</td><td><a href="https://www.fabriciobreve.com/artigos/slides/aici-slides.pdf" target="_blank" rel="noopener">CPM</a> <a href="https://pdfs.semanticscholar.org/b2f6/9a9b6a2c3b63e2bc76aeb7ba1df4cfe098a5.pdf" target="_blank" rel="noopener">SCP</a></td></tr><tr><td>基于种子扩散思想的社团发现</td><td>基本思想是以具有某种特征的子网络为种子，<br>通过合并、扩展等操作向邻接节点扩展，直至<br>获得评价函数最大的社团</td><td><a href="http://iopscience.iop.org/article/10.1088/1367-2630/11/3/033015/pdf" target="_blank" rel="noopener">LFM</a></td></tr><tr><td>基于混合概率模型的社团发现</td><td>以概率方法对复杂网络的社团结构进行探索，<br>以求得期望最大的社团结构，从而避开社团定义的问题</td><td><a href="http://www.pnas.org/content/pnas/104/23/9564.full.pdf" target="_blank" rel="noopener">Newman</a></td></tr><tr><td>基于边聚类的社团发现</td><td>以边为研究对象</td><td><a href="https://arxiv.org/pdf/0903.2181.pdf" target="_blank" rel="noopener">Line Graphs, Link Partitions</a> <br><a href="https://ucilnica.fri.uni-lj.si/pluginfile.php/1212/course/section/1202/Ahn%20et%20al%20-%20Link%20communities%20reveal%20multi-scale%20complexity%20in%20networks%2C%202010.pdf" target="_blank" rel="noopener">Yong-Yeol Ahn</a></td></tr></tbody></table><h3 id="频繁子图挖掘"><a href="#频繁子图挖掘" class="headerlink" title="频繁子图挖掘"></a>频繁子图挖掘</h3><blockquote><p>Frequent sub graph discovery is a process of identifying frequently occuring sub graphs from a set of graphs or a single large graph with frequency of occurrence is no less than a specified threshold.</p></blockquote><p>频繁子图挖掘一般包含以下两种方法：Apriori-based 和 Pattern growth based</p><ul><li>Apriori-based<blockquote><p>If a graph is frequent, all of its subgraphs are frequent.</p></blockquote></li></ul><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>AGM/AcGM</td><td></td><td><a href="https://pdfs.semanticscholar.org/33b8/3cf4471905abf2bb08e0e9cfef8c85d6bcc6.pdf" target="_blank" rel="noopener">AGM</a></td></tr><tr><td>FSG</td><td></td><td><a href="/resources/Frequent_Subgraph_Discovery.pdf">FSG</a></td></tr><tr><td>FFSM</td><td></td><td><a href="https://pdfs.semanticscholar.org/e45a/1cae5d7a9057263fec5c96d9659a7962a7bc.pdf" target="_blank" rel="noopener">FFSM1</a> <br><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.582.8488&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">FFSM2</a></td></tr></tbody></table><ul><li>Pattern growth based</li></ul><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>Subdue</td><td>基于最小描述长度原则 <strong>MDL</strong>来发现子结构<br>- 定义：$S$是图$G​$的一个子结构，$I(S)​$表示子结构$S​$的描述长度，$I(G&#124;S)​$表示在图$G​$中使用单个顶点替换子结构$S​$后得到的图的描述长度<br><br>- 寻找最优子结构：使得$I(S) = v\ bits + r\ bits + e\ bits​$最小的子结构$S​$，$S​$即为频繁子图。<br>其中$v\ bits​$表示表示编码图的顶点标签所需的$bit​$位数：<br>$$v\ bits = lg\ v + v\ lg\ l_u​$$<br>$r\ bits​$表示编码邻接矩阵$A​$的各行所需的$bit​$位数：<br>$$r\ bits = lg(b+1) + \sum_{i=0}^v lg(b+1) \ +lg\ C(v,k_i)​$$ <br>其中$b=max_ik_i​$，$k_i​$表示邻接矩阵$A​$第$i​$行中为$1​$的个数<br>$e\ bits​$表示编码邻接矩阵$A​$中以$A[i,j]=1​$所表示的边所需的$bit​$位数：<br>$$e\ bits=lg\ m\  +\ \sum_{i=1}^{v}\sum_{j=1}^{v} lg\ m + e(i,j)[1+lg\ l_u]​$$<br><br>- 过程：初始枚举单节点最优子结构，然后由此进行迭代。在每次迭代中，算法选择最优子结构后，通过增加一个顶点扩展当前子结构，直到所有的最优子结构都被列出或者所需考虑的候选最优子结构数量达到一定限制</td><td><a href="http://ailab.wsu.edu/subdue/papers/HolderAAAI-KDD94.pdf" target="_blank" rel="noopener">SUBDUE</a></td></tr><tr><td>gSpan</td><td></td><td><a href="https://www.cs.ucsb.edu/~xyan/software/gSpan.htm" target="_blank" rel="noopener">Xifeng Yan网站</a></td></tr><tr><td>Gaston</td><td></td><td><a href="http://liacs.leidenuniv.nl/~nijssensgr/gaston/documentation.html" target="_blank" rel="noopener">Gaston网站</a></td></tr><tr><td>CMTreeMiner</td><td></td><td><a href="https://pdfs.semanticscholar.org/ae20/abcf31a472f72aaf4b5332c759f668f29075.pdf" target="_blank" rel="noopener">CMTreeMiner</a></td></tr></tbody></table><h3 id="链接预测"><a href="#链接预测" class="headerlink" title="链接预测"></a>链接预测</h3><blockquote><p>通过已知的网络节点以及网络结构等信息预测网络中尚未产生连边的两个节点之间产生链接的可能性 ，包括对未知链接的预测和未来链接的预测</p></blockquote><ul><li>基于相似性的链路预测 Similarity-based methods</li></ul><blockquote><p>假设两个节点之间相似性越大，它们之间存在链接的可能性就越大。如何定义节点之间的相似性成为基于节点相似性的链路预测方法的核心问题，根据不同的相似性度量方法，可将该类相似性指标分为基于局部信息的相似性指标、基于路径的相似性指标和基于随机游走的相似性指标 </p></blockquote><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>基于局部信息的相似指标</td><td>- 共同邻居 （CN）</td><td></td></tr><tr><td>基于路径的相似性指标</td><td></td><td></td></tr><tr><td>基于随机游走的相似性指标</td><td></td></tr></tbody></table><ul><li>基于概率统计方法 Probabilistic and statistical method</li></ul><blockquote><p> 基本思想是建立一个含有一组可调参数的模型，然后使用优化策略寻找最优的参数值，使得所得到的模型能够更好地再现真实网络的结构和关系特征，网络中两个未连边的节点对连边的概率就是等于在改组最优参数下它们之间产生连边的条件概率</p></blockquote><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>概率关系模型 PRMs</td><td></td><td></td></tr><tr><td>有向无环概率实体关系模型 DAPER</td><td></td></tr></tbody></table><ul><li>基于最大似然估计的链路预测</li></ul><blockquote><p>很多网络的连接可以看作某种内在的层次结构的反映</p></blockquote><table><thead><tr><th>方法</th><th>描述</th><th>参考资料</th></tr></thead><tbody><tr><td>层次结构模型</td><td></td><td></td></tr><tr><td>随机分块模型</td><td></td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://itimetraveler.github.io/2016/11/21/%E5%9F%BA%E4%BA%8E%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0%E7%AE%97%E6%B3%95%E5%92%8C%E5%9B%BE%E5%88%86%E6%9E%90Neo4j%E8%A7%A3%E8%AF%BB%E3%80%8A%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B/#%E5%AF%BC%E8%AF%BB" target="_blank" rel="noopener">基于社区发现算法和图分析Neo4j解读《权力的游戏》</a></li><li><a href="http://sparkling-graph.readthedocs.io" target="_blank" rel="noopener">http://sparkling-graph.readthedocs.io</a></li><li><a href="https://blog.csdn.net/an_wu/article/details/68955242" target="_blank" rel="noopener">社区发现算法综述</a></li><li><a href="http://lamda.nju.edu.cn/liyf/dm14/111220090.pdf" target="_blank" rel="noopener">频繁子图数据挖掘研究综述</a></li><li><a href="https://www.ethz.ch/content/dam/ethz/special-interest/bsse/borgwardt-lab/documents/slides/CA10_GraphMining.pdf" target="_blank" rel="noopener">An Introduction to Graph Mining</a></li><li><a href="http://data-mining.philippe-fournier-viger.com/introduction-frequent-subgraph-mining/" target="_blank" rel="noopener">An introduction to frequent subgraph mining</a></li><li><a href="http://oop7j73zc.bkt.clouddn.com/%28%E7%BB%BC%E8%BF%B0-%E6%9C%80%E5%85%B7CSUR%202016%29%20A%20Survey%20of%20Link%20Prediction%20in%20Complex%20Networks.pdf" target="_blank" rel="noopener">A Survey of Link Prediction in Complex Networks</a></li><li><a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=5421" target="_blank" rel="noopener">复杂网路链路预测</a></li></ul>]]></content>
      
      <categories>
          
          <category> 知识图谱 </category>
          
          <category> 图分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图分析 </tag>
            
            <tag> 图挖掘 </tag>
            
            <tag> 节点中心性 </tag>
            
            <tag> 社区发现 </tag>
            
            <tag> 最短路径 </tag>
            
            <tag> 频繁图模式 </tag>
            
            <tag> 链接预测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scala 隐式转换implicit详解</title>
      <link href="/2018/05/24/scala-implicit/"/>
      <url>/2018/05/24/scala-implicit/</url>
      <content type="html"><![CDATA[<p>最近在使用<code>Spark-GraphX</code>做图相关的算法分析，想着深入看看源码的实现。由于对<code>Scala</code>不熟悉，只能边看源码边去了解<code>Scala</code>的特性。在分析过程中，发现很多地方使用<code>implicit</code>关键词，就想深入了解下<code>implicit</code>。</p><a id="more"></a><h3 id="Implicit简介"><a href="#Implicit简介" class="headerlink" title="Implicit简介"></a>Implicit简介</h3><p><strong>implicit</strong>，即隐式转换，是支撑<code>Scala</code>易用、容错以及灵活语法的基础。</p><blockquote><p>Scala的隐式转换系统定义了一套良好的查找机制，当代码出现类型编译错误时，编译器试图去寻找一个隐式<code>implicit</code>的转换方法，转换出正确的类型，从而使得编译器能够自我修复，完成编译。</p></blockquote><p>比如，在<code>Spark</code>源码中，经常会发现<code>RDD</code>这个类没有<code>reduceByKey</code>、<code>groupByKey</code>等方法定义，但是却可以在<code>RDD</code>上调用这些方法。这就是<code>Scala</code>隐式转换导致的。</p><p>参考<code>Spark</code>源码<code>core/src/main/scala/org/apache/spark/rdd/RDD.scala</code>文件，在<code>RDD</code>这个对象上定义了一个<code>rddToPairRDDFunctions</code>隐式转换（在1.3版本之前，该隐式转换定义在SparkContext对象中）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines implicit functions that provide extra functionalities on RDDs of specific types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example, [[RDD.rddToPairRDDFunctions]] converts an RDD into a [[PairRDDFunctions]] for</span></span><br><span class="line"><span class="comment"> * key-value-pair RDDs, and enabling extra functionalities such as `PairRDDFunctions.reduceByKey`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RDD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> <span class="type">CHECKPOINT_ALL_MARKED_ANCESTORS</span> =</span><br><span class="line">    <span class="string">"spark.checkpoint.checkpointAllMarkedAncestors"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following implicit functions were in SparkContext before 1.3 and users had to</span></span><br><span class="line">  <span class="comment">// `import SparkContext._` to enable them. Now we move them here to make the compiler find</span></span><br><span class="line">  <span class="comment">// them automatically. However, we still keep the old functions in SparkContext for backward</span></span><br><span class="line">  <span class="comment">// compatibility and forward to the following functions directly.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">rddToPairRDDFunctions</span></span>[<span class="type">K</span>, <span class="type">V</span>](rdd: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)])</span><br><span class="line">    (<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], vt: <span class="type">ClassTag</span>[<span class="type">V</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>): <span class="type">PairRDDFunctions</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">PairRDDFunctions</span>(rdd)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>rddToPairRDDFunctions</code>隐式转换，即将<code>RDD[(K, V)]</code>类型的rdd转换为<code>PairRDDFunctions</code>对象，从而可以在原始的rdd对象上调用<code>reduceByKey</code>之类的方法。</p><p>那为什么执行完<code>reductByKey</code>方法后，返回的还是原始的<code>rdd</code>对象了？那是因为每次执行完<code>PairRDDFunctions</code>对象方法后，会返回<code>rdd</code>对象。</p><p>类型隐式转换是在需要的时候才会触发，如果调用需要进行隐式转换的方法，隐式转换才会进行，否则还是传统的RDD类型的对象。</p><p>隐式转换对于代码重构提供了一种新的思路，比如公司有一个历时悠久的用户认证系统，各大业务系统一般会引入以下认证服务接口进行认证授权：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpAuthParam</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">HttpAuthParam</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是随着业务的发展，有些需要支持<code>TCP</code>协议的授权认证。一种方法是在<code>IAuthService</code>接口对<code>auth</code>方法进行重载，以满足<code>TCP</code>参数形式，那么就有：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">HttpAuthParam</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新版中支持对tcp消息鉴权的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">TcpAuthMsg</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法的问题在于，一旦业务发生变化，出现了新的参数，势必要修改<code>IAuthService</code>接口，添加新的接口方法，导致接口不稳定。</p><p>我们可以定义一个通用稳定的认证授权接口：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthParam</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 稳定的授权接口</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">AuthParam</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口服务实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthService</span> <span class="keyword">extends</span> <span class="title">IAuthService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">AuthParam</span>) = &#123;</span><br><span class="line">        println(<span class="string">"默认鉴权服务请求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对<code>AuthService</code>类进行隐式转换，增加<code>TCP</code>服务鉴权方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpAuthMsg</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tcpAuthService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式类转换</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpAuth</span>(<span class="params">authService: <span class="type">AuthService</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span></span>(p: <span class="type">TcpAuthMsg</span>) = &#123;</span><br><span class="line">println(<span class="string">"TCP鉴权服务请求"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以在需要调用TCP方式时导入该隐式转换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入隐式转换</span></span><br><span class="line"><span class="keyword">import</span> tcpAuthService._</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Tcp授权认证</span></span><br><span class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">TcpAuthMsg</span>()</span><br><span class="line"><span class="keyword">val</span> authService = <span class="keyword">new</span> <span class="type">AuthService</span>()</span><br><span class="line">authService.auth(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果:</span></span><br><span class="line"><span class="comment">// &gt; scala auth_implicit.scala</span></span><br><span class="line"><span class="comment">// TCP鉴权服务请求</span></span><br></pre></td></tr></table></figure><p>通过这个例子可知，通过类的隐式转换可以在不修改原有系统代码之下，对类进行方法重载，提升接口的稳定性。</p><p>当然，万事都是一把双刃剑，<code>implicit</code>使得Scala变的非常灵活，但增加了开发者阅读代码的难度，因为你不知道作者在哪些地方实现了<code>implicit</code>。</p><p>下面，就让我们来详细看看Scala里支持哪些<code>implicit</code>类型，以及应用隐式转换规则的限定条件。</p><h3 id="隐式转换类型"><a href="#隐式转换类型" class="headerlink" title="隐式转换类型"></a>隐式转换类型</h3><p>Scala隐式转换类型主要包括以下几种类型：隐式参数、隐式试图、隐式类。</p><h4 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h4><blockquote><p>隐式参数是在编译器找不到函数需要某种类型的参数时的一种修复机制。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(amout: <span class="type">Float</span>)(<span class="keyword">implicit</span> rate: <span class="type">Float</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(amout * rate)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 隐式参数</span></span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">val</span> r = <span class="number">0.13</span>F  <span class="comment">// 定义隐式变量</span></span><br><span class="line">        foo(<span class="number">10</span>)  <span class="comment">// 输出1.3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>foo</code>参数中申明了隐式参数<code>rate</code>（即用<code>implicit</code>标记），在调用<code>foo</code>方法时，Scala编译器会从当前作用域中寻找一个相同类型的隐式变量，作为调用参数。如果没有找到找到，则会报错。</p><h4 id="隐式视图"><a href="#隐式视图" class="headerlink" title="隐式视图"></a>隐式视图</h4><blockquote><p>隐式视图，是指把一种类型自动转换到另外一种类型，以符合表达式的要求。</p></blockquote><p>隐式视图定义一般用如下形式：<code>implicit def &lt;ConversionName&gt; (&lt;argumentName&gt;: OriginalType): ViewType</code>。在需要的时候，如果隐式作用域里存在这个定义，它会隐式地把 <code>OriginalType</code> 类型的值转换为<code>ViewType</code> 类型的值。</p><p>隐式视图包含两种转换类型：隐式类型转换以及隐式方法调用。</p><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><blockquote><p>隐式类型转换是编译器发现传递的数据类型与申明不一致时，编译器在当前作用域查找类型转换方法，对数据类型进行转换。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">double2Int</span></span>(d: <span class="type">Double</span>) = d.toInt</span><br><span class="line">    <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">3.5</span></span><br><span class="line">    println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>i</code>申明为<code>Int</code>类型，但是赋值<code>Double</code>类型数据，显然编译通不过。这个时候可以借助隐式类型转换，定义<code>Double</code>转<code>Int</code>规则，编译器就会自动查找该隐式转换，将<code>3.5</code>转换成<code>3</code>，从而达到编译器自动修复效果。</p><h5 id="隐式方法调用"><a href="#隐式方法调用" class="headerlink" title="隐式方法调用"></a>隐式方法调用</h5><blockquote><p>隐式方法调用是当编译器发现一个对象存在未定义的方法调用时，就会在当前作用域中查找是否存在对该对象的类型隐式转换，如果有，就查找转换后的对象是否存在该方法，存在，则调用。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drinking</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"I can drinking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Crow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">drinking</span></span>&#123;</span><br><span class="line">    <span class="comment">// 隐式方法调用</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">extendSkill</span></span>(c: <span class="type">Crow</span>) = <span class="keyword">new</span> <span class="type">Horse</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 隐式转换调用类中不存在的方法</span></span><br><span class="line">    <span class="keyword">import</span> drinking._</span><br><span class="line">    <span class="keyword">var</span> crow = <span class="keyword">new</span> <span class="type">Crow</span>()</span><br><span class="line">    crow.drinking()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>crow</code>对象并没有<code>drinkging()</code>方法定义，但是通过隐式规则转换，可以扩展<code>crow</code>对象功能，使其可以拥有<code>Horse</code>对象的功能。</p><h4 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h4><blockquote><p>Scala 2.10引入了一种叫做隐式类的新特性。隐式类指的是用implicit关键字修饰的类。在对应的作用域内，带有这个关键字的类的主构造函数可用于隐式转换。</p></blockquote><p>举个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Crow</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">crow_eval</span></span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Parrot</span>(<span class="params">animal: <span class="type">Crow</span></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(say: <span class="type">String</span>): <span class="type">Unit</span> = &#123;println(<span class="string">s"I have the skill of Parrot: <span class="subst">$say</span>"</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 隐式类</span></span><br><span class="line">    <span class="keyword">import</span> crow_eval._</span><br><span class="line">    crow.say(<span class="string">"balabala"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建隐式类时，只需要在对应的类前加上<code>implicit</code>关键字。</p><p>使用隐式类时，需要注意以下几点：</p><ul><li>构造参数有且只有一个，且为非隐式参数</li><li>隐式类必须被定义在类、伴生对象和包对象里</li><li>隐式类不能是<code>case class</code>（<code>case class</code>会自动生成伴生对象，与上一条矛盾）</li><li>作用域内不能有与之同名的标识符</li></ul><h3 id="隐式解析机制"><a href="#隐式解析机制" class="headerlink" title="隐式解析机制"></a>隐式解析机制</h3><p>编译器是如何查找到缺失信息的，解析具有以下两种规则：</p><ol><li><p>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）</p></li><li><p>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。</p><p>类型的作用域是指与该类型相关联的全部伴生模块，一个隐式实体的类型T，它的查找范围如下：</p><ul><li>如果T被定义为<code>T with A with B with C</code>，那么A、B、C都是T的部分，在T的隐式解析过程中，它们的伴生对象都会被搜索</li><li>如果T是参数化类型，那么类型参数和与类型参数相关联的部分都算作T的部分，比如<code>List[String]</code>的隐式搜索会搜索List的伴生对象和String的伴生对象</li><li>如果T是一个单例类型<code>p.T</code>，即T是属于某个p对象内，那么这个p对象也会被搜索</li><li>如果T是个类型注入<code>S#T</code>，那么S和T都会被搜索</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>implicit</code>是Scala语言中处理编译类型错误的一种修复机制，利用该机制，可以编写出任意参数和返回值的多态方法（<code>Ad-hoc polymorphism</code>任意多态），实现任意多态。</p><p>隐式转换一般需要具备以下前提条件：</p><ul><li>不存在二义性</li><li>隐式操作不能嵌套使用，比如需要<code>C</code>类型参数，而实际类型为<code>A</code>，作用域内存在<code>A =&gt; B</code>,<code>B =&gt; C</code>的隐式方法，Scala编译器不会尝试先调用<code>A =&gt; B</code> ,再调用<code>B =&gt; C</code>。 </li><li>代码能够在不使用隐式转换的前提下能编译通过，就不会进行进行隐式转换</li></ul><p>在实际开发过程中，如果对隐式规则掌握不清楚，往往出了问题会无从查起，笔者建议谨慎使用。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.jianshu.com/p/1d119c937015" target="_blank" rel="noopener">Scala中的Implicit详解</a></li><li><a href="https://docs.scala-lang.org/zh-cn/overviews/core/implicit-classes.html" target="_blank" rel="noopener">https://docs.scala-lang.org/zh-cn/overviews/core/implicit-classes.html</a></li><li><a href="https://blog.csdn.net/oopsoom/article/details/24643869" target="_blank" rel="noopener">scala implicit 隐式转换</a></li></ol>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> implicit </tag>
            
            <tag> 隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 小整数与大整数的处理机制以及整体解释与逐行解释的区别</title>
      <link href="/2018/05/17/py-int-confusing/"/>
      <url>/2018/05/17/py-int-confusing/</url>
      <content type="html"><![CDATA[<p>分析以下代码的执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line">print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line">print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line">print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line">print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><a id="more"></a><p>保存为<code>test.py</code>并执行<code>python3 test.py</code>，运行结果如下 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a is b True</span><br><span class="line">c is d True</span><br><span class="line">a is e True</span><br><span class="line">c is f False</span><br><span class="line">f is g True</span><br></pre></td></tr></table></figure><p>这里先说明下<code>is</code>和<code>==</code>的区别：</p><ul><li><code>is</code>操作符是比较两个实例对象是不是同一个对象，即内存地址是否相同</li><li><code>==</code>操作符是比较两个实例对象内容是不是一样，即内存地址可能不一样</li></ul><p>分析以上结果可知，变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>是同一个对象。但<strong>为什么<code>a</code>和<code>e</code>是同一个对象，而<code>c</code>和<code>f</code>不是同一个对象？</strong></p><p>对以上代码，在终端逐行执行，看看结果会是怎么样的。执行过程及结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    e = <span class="number">256</span></span><br><span class="line"><span class="meta">... </span>    f = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    g = <span class="number">257</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is b'</span>, a <span class="keyword">is</span> b)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is d'</span>, c <span class="keyword">is</span> d)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'a is e'</span>, a <span class="keyword">is</span> e)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'c is f'</span>, c <span class="keyword">is</span> f)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'f is g'</span>, f <span class="keyword">is</span> g)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">a <span class="keyword">is</span> b <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> d <span class="keyword">False</span></span><br><span class="line">a <span class="keyword">is</span> e <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> f <span class="keyword">False</span></span><br><span class="line">f <span class="keyword">is</span> g <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>为啥<code>c</code>和<code>d</code>不是同一个对象了？</strong></p><p>解释以上结果，需要了解<code>Python</code>语言的<strong>小整数与大整数</strong>的处理机制以及<strong>整体解释与逐行解释</strong>的区别。</p><h3 id="小整数与大整数"><a href="#小整数与大整数" class="headerlink" title="小整数与大整数"></a>小整数与大整数</h3><p>学过<code>java</code>的都知道，在<code>JDK5</code>中，为<code>Integer</code>的操作引入了一个新的特性，用来节省内存和提高性能。<code>[-128, 127]</code>之间的整形对象在内部实现中通过使用相同的对象引用实现了缓存和重用。为什么对这个区间范围的整数进行缓存？主要是因为这个范围的整数值使用最广泛（<code>JDK6</code>之后可以通过<code>jvm</code>启动参数设置最大值）。</p><p>在<code>Python</code>中，同样采用了类似的整形缓存机制。<code>Python</code>将整数的定义细分为小整数和大整数，前者整数值范围为<code>[-5, 257)</code>，其余整数为后者。</p><h4 id="小整数对象缓存池"><a href="#小整数对象缓存池" class="headerlink" title="小整数对象缓存池"></a>小整数对象缓存池</h4><p><code>Python</code>将小整数缓存到一个特定的<code>small_ints</code>链表中，该链表会存在于<code>Python</code>解释器的整个生命周期，当需要使用小整数时，就去该链表中获取。简单来说，<strong>小整数对象会在Python全局解析器范围内被重复引用，且永远不会被GC回收</strong>。</p><h4 id="通用整数对象缓存池"><a href="#通用整数对象缓存池" class="headerlink" title="通用整数对象缓存池"></a>通用整数对象缓存池</h4><p><code>Python</code>运行环境会为大整数对象分配一定的缓存内存空间，该内存空间会被大整数对象轮流使用，直到占满为止，再继续则开辟一块新的内存空间。通过分析<code>Python</code>源码可知，通用整数对象缓存池的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>PyIntBlock</code>结构体定义了一个<code>PyIntObject</code>数组和指向下一个<code>PyIntBlock</code>结构的指针<code>*next</code>。每个block大约可以存放82个<code>PyIntObject</code>。<code>block_list</code>用于维护分配给<code>PyIntObject</code>所有的内存空间，<code>free_list</code>则用于维护<code>PyIntObject</code>可用的剩余内存空间。</p><ul><li><p>当<code>free_list</code>为<code>NULL</code>时，<code>Python</code>会重新<code>malloc</code>一个新的block出来。</p></li><li><p>当一个大整数对象的引用计数为0需要被回收时，其占用的内存空间并不会被回收，而是放到<code>free_list</code>数组中，供新创建的整数对象使用，从而减少内存创建、释放带来的开销。</p></li></ul><p>综上所述，可以解释变量<code>a/b</code>、<code>c/d</code>、<code>a/e</code>、<code>f/g</code>为什么是同一个对象。但是还不足以解释<code>c/f</code>以及在终端执行时<code>c/d</code>的结果。这就需要了解<strong>Python的解析模式</strong>——整体解释和逐行解释。</p><h3 id="整体解释与逐行解释"><a href="#整体解释与逐行解释" class="headerlink" title="整体解释与逐行解释"></a>整体解释与逐行解释</h3><p><strong>整体解释</strong>指的通过应用程序的方式来运行Python代码，而<strong>逐行解释</strong>是在交互式解释器中执行Python代码。在Python中，解析器的<strong>编译单元是一个函数</strong>（Python顶层代码也被当作一个函数来进行编译）。每个函数单独编译后会得到一个<code>PyFunctionObject</code>对象，该对象包含了字节码、常量池等信息。</p><p>每个<code>PyFunctionObject</code>都拥有一个独立的常量池，如果在同一个<code>PyFunctionObject</code>里创建了值相同的常量，那么这些常量只会在常量池里出现一份。</p><p>由此可知，问题中总共包含两个<code>PyFunctionObject</code>对象——由顶层函数和<code>foo</code>函数编译。顶层变量<code>c/d</code>和位于<code>foo</code>函数中的<code>f/g</code>分别位于两个不同的<code>PyFunctionObject</code>对象中，虽然值相同，但是内存地址不同。这就解释了<code>c/f</code>的运行结果。那为什么<code>a/e</code>两个变量是相同的对象了，那是因为小整数是全局解释器缓存的！</p><p>那么就剩一个问题了，为什么在交互式命令行终端<code>c/d</code>不是同一个对象了？</p><p>那是因为在交互式中，每输入一行语句就会立即执行，即<strong>编译单元是一行语句</strong>，每执行一行语句就会得到一个<code>PyFunctionObject</code>对象。注意，这里所说的“一行”是指的一次完整性输入。</p><p>综上所述，可以得到以下结论：</p><ul><li>整体解释是以函数为编译单元的，而交互式终端是以一行语句输入为编译单元，每个编译单元具有独立的常量池</li><li>小整数范围为<code>[-5, 257)</code>，缓存在全局解释器中，而大整数缓存在编译单元中</li></ul><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>修改<code>foo</code>函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">257</span></span><br><span class="line">d = <span class="number">257</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(h=<span class="number">256</span>, i=<span class="number">257</span>)</span>:</span></span><br><span class="line">e = <span class="number">256</span></span><br><span class="line">f = <span class="number">257</span></span><br><span class="line">g = <span class="number">257</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">'a is h'</span>, a <span class="keyword">is</span> h)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'c is i'</span>, c <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line">print(<span class="string">'f is i'</span>, f <span class="keyword">is</span> i)  <span class="comment"># ?</span></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p> 运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span> h <span class="keyword">True</span></span><br><span class="line">c <span class="keyword">is</span> i <span class="keyword">True</span></span><br><span class="line">f <span class="keyword">is</span> i <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小整数 </tag>
            
            <tag> 大整数 </tag>
            
            <tag> 整数缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode31 下一个排列</title>
      <link href="/2018/05/04/n31-next-permutation/"/>
      <url>/2018/05/04/n31-next-permutation/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-permutation/description/" target="_blank" rel="noopener">LeetCode第31题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有数字序列n~1~n~2~n~3~…n~i~…n~m~，定义左边为高位，右边为低位。从低位向高位逐位比较，</p><p>如果n~i~ &lt;= n~i-1~，则继续向高位进位比较下一组（即i–）；</p><p>如果n~i~&gt;n~i-1~，则在n~i~ ~ n~m~之间寻找比n~i-1~大的最小数字，并与之交换。</p><p>最后对n~i~ ~ n~m~数字序列按从小到大进行排序，得到最终数字排列即为答案。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 从i -&gt; n中选择比nums[i-1]大的最小数字</span></span><br><span class="line">                j = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= i:</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &lt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    nums[i<span class="number">-1</span>], nums[j] = nums[j], nums[i<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 i -&gt; n 进行翻转，按从小到大排列</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; (len(nums)<span class="number">-1</span>-i) / <span class="number">2</span>:</span><br><span class="line">            nums[i+k], nums[len(nums)<span class="number">-1</span>-k] = nums[len(nums)<span class="number">-1</span>-k], nums[i+k]</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode30 与所有单词相关联的字串</title>
      <link href="/2018/05/03/n30-substring-with-concatenation-of-all-words/"/>
      <url>/2018/05/03/n30-substring-with-concatenation-of-all-words/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="noopener">LeetCode第30题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个字符串 <strong>s</strong> 和一些<strong><em>长度相同</em></strong>的单词 <strong>words。</strong>在 <strong>s</strong> 中找出可以恰好串联 <strong>words</strong> 中所有单词的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出: [0,9]</span><br><span class="line">解释: 从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先将<code>words</code>转换成字典<code>word_dict</code>，<code>key</code>为单词，<code>value</code>为单词出现的次数。以<code>words</code>所有单词总长度为窗口，截取字符串<code>s</code>，然后再将子串以单词长度进行分割。如果分割出的子串包含于<code>words</code>中，则<code>word_dict</code>计数相应的减1（计数等于0时，移除该单词），否则进行下一窗口截取。如果最后<code>word_dict</code>为空，则表示找到字符串可以用<code>words</code>所有单词完全匹配。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        word_num = len(words)</span><br><span class="line">        word_len = len(words[<span class="number">0</span>])</span><br><span class="line">        n_word_len = word_len * word_num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        d = word_dict.copy()</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p+n_word_len]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 每隔word_len进行截取，判断word_dict是否包含该子串</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(word_num):</span><br><span class="line">                item = sub[i*word_len: (i+<span class="number">1</span>)*word_len]</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[item] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[item] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> d[item]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果word_dict为空，找到子串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">                res.append(p)</span><br><span class="line">                </span><br><span class="line">            d = word_dict.copy()</span><br><span class="line"> </span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><p>本题需要匹配的<code>words</code>列表单词长度是<strong>相同</strong>的，如果不相同了？</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">  s = &quot;barrfothefoobarman&quot;,</span><br><span class="line">  words = [&quot;fo&quot;,&quot;barr&quot;]</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 从索引 0 开始的子串为barrfo，可以用words所有单词完全匹配。</span><br></pre></td></tr></table></figure><p>基于以上思路，一种方法是修改子串的校验方法，使用逐字比较。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        n_word_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用字典记录单词出现的次数 &lt;单词，次数&gt;</span></span><br><span class="line">        word_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            n_word_len += len(word)</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">                word_dict[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dict[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p + n_word_len &lt;= len(s):</span><br><span class="line">            <span class="comment"># 取n_word_len长度子串</span></span><br><span class="line">            sub = s[p:p + n_word_len]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 逐字比较</span></span><br><span class="line">            <span class="keyword">if</span> self.word_cmp(sub, word_dict):</span><br><span class="line">                res.append(p)</span><br><span class="line"></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word_cmp</span><span class="params">(self, s, word_dict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> word_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        d = word_dict.copy()</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(s):</span><br><span class="line">            sub = s[<span class="number">0</span>:i]</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sub] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[sub] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> d[sub]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.word_cmp(s[i:], d):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode29 两数相除</title>
      <link href="/2018/05/01/n29-divide-two-integers/"/>
      <url>/2018/05/01/n29-divide-two-integers/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">LeetCode第29题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>除法是乘法的逆运算，假设 dividend / divisor = n，那么有dividend = divisor * n，亦可表示为n个数进行累加dividend = divisor + … + divisor。解答本题的基本思路即通过对除数进行累加直到超过被除数，累加的次数即为商。显然，这种方法运行效率不高，评测执行超时。那有没有什么方法在此算法基础上提升效率了，先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">求 12/2 的商，转换成加法，即：</span><br><span class="line">12 = 2 + 2 + 2 + 2 + 2 + 2</span><br><span class="line">共累加6次，即商为6。</span><br><span class="line"></span><br><span class="line">通过观察发现，每次都是累加同一个数字，能不能减少加法运算，快速逼近12？答案对除数进行移位操作。</span><br><span class="line"></span><br><span class="line">轮次  |     移位        |    商</span><br><span class="line">1        4 (2 &lt;&lt;= 1)       2 (1 &lt;&lt;= 1)</span><br><span class="line">2        8 (4 &lt;&lt;= 1)       4 (2 &lt;&lt;= 1)</span><br><span class="line">3        16 (8 &lt;&lt;= 1) 退出循环</span><br><span class="line"></span><br><span class="line">经过两轮循环，除数为8，商为4，余数为12 - 8 = 4。然后继续使用相同的方法计算4/2的商。</span><br><span class="line"></span><br><span class="line">轮次  |     移位    |    商</span><br><span class="line">1       4 (2 &lt;&lt;= 1)     2 (1 &lt;&lt;= 1)</span><br><span class="line">2       8 (4 &lt;&lt;= 1)  退出循环</span><br><span class="line"></span><br><span class="line">则12/2商为 4 + 2 = 6。通过此算法，共减少了3次加法运算。</span><br></pre></td></tr></table></figure><p>通过对除数进行移位操作可较少加法次数，从而提升算法执行效率。考虑到被除数或除数可能出现负数情况，可先计算商的正负情况，然后取被除数和除数的绝对值进行除法运算，最后再设置商的符号。</p><p>算法伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">令商result = 1 </span><br><span class="line">计算商是否为负数 neg = (dividend &lt; 0) ^ (divisor &lt; 0)</span><br><span class="line">取被除数、除数绝对值 dividend = abs(dividend), divisor = abs(divisor)</span><br><span class="line">假如 dividend &lt; divisor, 则返回0</span><br><span class="line">初始化count, n = 1, divisor</span><br><span class="line">while (n &lt;&lt; 1) &lt;= dividend</span><br><span class="line">   n &lt;&lt;= 1</span><br><span class="line">   count &lt;&lt;= 1</span><br><span class="line">result += count</span><br><span class="line">令dividend = dividend - n, 重复步骤4</span><br><span class="line">如果reg是负数, 则返回-result, 否则返回result (需考虑整数溢出情况)</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        neg  = (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dividend &lt; divisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>:  <span class="comment"># 当除数是1时，商直接设置为dividend</span></span><br><span class="line">            result = dividend</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="number">1</span></span><br><span class="line">            tmp = divisor</span><br><span class="line">            <span class="keyword">while</span> (tmp &lt;&lt; <span class="number">1</span>) &lt;= dividend:</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span></span><br><span class="line">                result &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            result += self.divide(dividend - tmp, divisor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理正整数除法溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> result &gt;= <span class="number">2</span> ** <span class="number">31</span> <span class="keyword">and</span> <span class="keyword">not</span> neg:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -result <span class="keyword">if</span> neg <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><p>以上代码使用<code>Python3</code>编写，注意<code>Python3</code>没有<code>long</code>类型，<code>int</code>整形没有大小限制。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://tryanswer.github.io/2018/04/20/n25-reverse-nodes-in-k-group/">LeetCode25 k个一组翻转链表</a></li><li><a href="http://www.hui-wang.info/2017/10/27/计算机中的数学/">计算机中的数学</a></li><li><a href="http://www.hui-wang.info/2017/11/25/数学之美：不能再凑了/">数学之美：不能再凑了</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 除法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode25 k个一组翻转链表</title>
      <link href="/2018/04/20/n25-reverse-nodes-in-k-group/"/>
      <url>/2018/04/20/n25-reverse-nodes-in-k-group/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">LeetCode第25题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。<br>示例 :<br>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code><br>当 k = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code><br>当 k = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>说明:</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">交换链表节点题</a>的延伸。本题解题思路可以采用递归法，先翻转前k个节点(如果链表小于k个节点，直接返回链表)，然后递归对其余节点进行翻转，最后将两者接上。<br>由于头节点可能会改变，所以在链表头部插入一个空节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        new_head.next = head</span><br><span class="line">        p = head</span><br><span class="line">        </span><br><span class="line">        node_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node_count &lt; k <span class="keyword">and</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            node_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node_count == k:</span><br><span class="line">    <span class="comment"># 对剩余的节点进行K-组翻转</span></span><br><span class="line">            current_node = self.reverseKGroup(p, k)</span><br><span class="line">    <span class="comment"># 对本次k节点进行翻转，并接上current_node</span></span><br><span class="line">            <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                temp = new_head.next</span><br><span class="line">                new_head.next = temp.next</span><br><span class="line">                temp.next = current_node</span><br><span class="line">                current_node = temp</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里需要将空节点指向current_node</span></span><br><span class="line">            new_head.next = current_node</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://tryanswer.github.io/2018/04/15/n24-swap-nodes-in-pairs/">LeetCode24 两两交换链表中的节点</a></li><li><a href="https://tryanswer.github.io/2018/04/13/n23-merge-k-sorted-lists/">LeetCode23 合并K个有序链表</a></li><li><a href="https://tryanswer.github.io/2018/05/01/n29-divide-two-integers/">LeetCode29 两数相除</a></li><li><a href="http://www.hui-wang.info/2017/11/18/动画解释如何求单链表环入口点/">动画解释如何求单链表环入口点</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode24 两两交换链表中的节点</title>
      <link href="/2018/04/15/n24-swap-nodes-in-pairs/"/>
      <url>/2018/04/15/n24-swap-nodes-in-pairs/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">LeetCode第24题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有P-&gt;A-&gt;B-&gt;C-&gt;…链表，交换A、B节点即把A.next指向C，B.next指向A，P.next指向B。算法步骤如下图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqdnfvn8p3j30nk0pgdgf.jpg" width="400"><br>在实现时，可以在头部添加一个空结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 插入一个空的节点，指向head</span></span><br><span class="line">        p = ListNode(<span class="number">0</span>)</span><br><span class="line">        p.next = head</span><br><span class="line">        head = p</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">and</span> p.next.next:</span><br><span class="line">            temp = p.next.next</span><br><span class="line">            p.next.next = p.next.next.next</span><br><span class="line">            temp.next = p.next</span><br><span class="line">            p.next = temp</span><br><span class="line">            p = p.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://tryanswer.github.io/2018/04/13/n23-merge-k-sorted-lists/">LeetCode23 合并K个有序链表</a></li><li><a href="https://tryanswer.github.io/2018/04/20/n25-reverse-nodes-in-k-group/">LeetCode25 k个一组翻转链表</a></li><li><a href="http://www.hui-wang.info/2017/11/18/动画解释如何求单链表环入口点/">动画解释如何求单链表环入口点</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员密码</title>
      <link href="/2018/04/14/programmers-pwd/"/>
      <url>/2018/04/14/programmers-pwd/</url>
      <content type="html"><![CDATA[<p>这几天在<a href="https://www.v2ex.com/t/445123" target="_blank" rel="noopener">V2EX</a>上看到一个面向程序员的小游戏——在网页中找到一个隐藏的密码即可过关。游戏目前总共有两个level, level1有10道题，level2有5道题。游戏规则虽然简单，但是想要过关还是需要掌握不少知识，比如：’Chrome Developer Tools’工具使用、Baes64解码、图片隐写术等等。<br>游戏挺有意思的，在这里记录下，写者无心，读者请闭眼。</p><a id="more"></a><h2 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h2><p>进入游戏只有一个密码输入框，第一反应是打开开发者工具，寻找蛛丝马迹。通过细心观察，果然发现<code>Console</code>有信息打印，并且对源码进一步分析，游戏核心代码在<code>js/app/level.js</code>文件里。<code>level.js</code>粗略看下来，主要包含两部分重要信息：关卡通过对玩家输入的密码进行<code>md5</code>加密验证以及每个关卡执行的函数(存放在<code>LevelManager.prototype.levels</code>数组里)。<br>总体分析下来，得到的信息如下：<br>1）Console有信息提示<br>2）每个关卡的触发函数<br>3）md5加密</p><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1-0"></a>level1-0</h3><p>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p><h3 id="level1-1"><a href="#level1-1" class="headerlink" title="level1-1"></a>level1-1</h3><p>对<code>Console</code>打印的信息进行Base64解码 (为啥会想到Base64？因为字符最后的<code>=</code>号)<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;m a programmer.</span><br></pre></td></tr></table></figure></p><h3 id="level1-2"><a href="#level1-2" class="headerlink" title="level1-2"></a>level1-2</h3><p>对<code>cGluZyB3d3cucHJvZ3JhbW1lcnBhc3N3b3JkLmNvbQ==</code>进行Base64解码，得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.programmerpassword.com</span><br></pre></td></tr></table></figure></p><p>进而在终端执行ping，获取ip地址<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47.104.152.148</span><br></pre></td></tr></table></figure></p><h3 id="level1-3"><a href="#level1-3" class="headerlink" title="level1-3"></a>level1-3</h3><p>本关卡没有在<code>Console</code>里打印信息，但是通过对关卡函数分析，本关卡在页面上插入了一段<code>html</code>代码，并且设置了透明样式。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码是123456</span><br></pre></td></tr></table></figure></p><h3 id="level1-4"><a href="#level1-4" class="headerlink" title="level1-4"></a>level1-4</h3><p><code>Console</code>打印了一串数字，使用<code>String.fromCharCode()</code>将十六进制整数转ascii码。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bug running</span><br></pre></td></tr></table></figure></p><h3 id="level1-5"><a href="#level1-5" class="headerlink" title="level1-5"></a>level1-5</h3><p>本关卡在页面上插入了一段<code>html</code>代码，只显示了一个<code>#</code>。开始以为是和<code>jQuery</code>的id选择器有关，结果答案却是<code>#</code>文字的RGB颜色值。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2f4584</span><br></pre></td></tr></table></figure></p><h3 id="level1-6"><a href="#level1-6" class="headerlink" title="level1-6"></a>level1-6</h3><p>图片的Base64编码，需要添加头部<code>data:image/jpeg;</code>。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">463700</span><br></pre></td></tr></table></figure></p><h3 id="level1-7"><a href="#level1-7" class="headerlink" title="level1-7"></a>level1-7</h3><p>访问<code>img.src</code>指定的url。<br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better to miss than to meet</span><br></pre></td></tr></table></figure></p><h3 id="level1-8"><a href="#level1-8" class="headerlink" title="level1-8"></a>level1-8</h3><p>在<code>Console</code>里输入<code>window.getPassword(&quot;H4sIAAAAAAAAC7MPcHq2ZWH987ndEfYA5w4bAwwAAAA=&quot;)</code><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25LTQWMP9Y</span><br></pre></td></tr></table></figure></p><h3 id="level1-9"><a href="#level1-9" class="headerlink" title="level1-9"></a>level1-9</h3><p>最坑爹的关卡，以为密码会隐藏在给出的PHP代码里，然而，然而，被坑了。。。把图片下载下来，然后使用十六进制编辑器打开图片，从jpg图片里可找到<code>cd /data/log/../www/; pwd</code>附加信息。<br>jpg隐写技巧原理可以参考这篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8JPEG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8Fpayload/" target="_blank" rel="noopener">隐写技巧-利用JPEG文件格式隐藏payload</a><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/www</span><br></pre></td></tr></table></figure></p><p>总结Level1关卡，整体难度其实并不高，只要善于使用谷歌开发者工具以及掌握Html&amp;Css、Base64编码、JPG隐写术等知识点就能轻松过关。</p><h2 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h2><p>Level2总共有5道题，虽然题目减少，但是难度较Level1提升了好几个档次。当然，坑更多…</p><h3 id="level2-0"><a href="#level2-0" class="headerlink" title="level2-0"></a>level2-0</h3><p>页面提示区显示了一段乱码，显然本关卡只需要解决乱码问题即可找到密码。<br>打开开发者工具，找到发起的ajax请求，如下图：<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fqd3pnqa4xj30lq07aglt.jpg" alt="关卡请求"><br>通过分析可以发现，Html页面编码采用UTF-8，而ajax请求Http Response Content-Type Header设置了GBK编码类型，这就是导致乱码的原因。破解此题，只需如下操作：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd3urupjdj30lo0byaaj.jpg" alt="拷贝Curl请求"><br>右键拷贝curl请求，然后打开终端，执行curl请求：<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fqd3xbjeqpj31kw02kdgb.jpg" alt="执行Curl请求"><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">春花秋月何时了</span><br></pre></td></tr></table></figure></p><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2-1"></a>level2-1</h3><p>本关卡提示信息是一张写有二进制的图片，显然第一反应是把图片上的二进制转成字符串，可以得到<code>error!</code>。经过试验，密码并不是<code>error!</code>。那么<code>error!</code>这几个字母是不是作者给我们的提示了，记过漫长时间的思考，终究没有找到答案。得放弃这个方向了，又是图片隐写术了？把图片下载下来，分析发现这是一张正常的图片，并没有添加额外的附加信息。又经过一段时间的思考，突然想到，是不是密码存放在图片属性里。立马右键图片，查看属性内容，果然图片添加了“备注”，心里一乐。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fqd4mgsottj30bm0i0jrr.jpg" alt=""><br>密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCFHJJUKLI</span><br></pre></td></tr></table></figure></p><p>上文里其实介绍过JPG隐写术，本关卡也是隐写术的一种，使用<a href="http://www.impulseadventure.com/photo/jpeg-snoop.html" target="_blank" rel="noopener">JPEGsnoop</a>工具打开图片亦可查找到备注信息。</p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
          <category> 程序员密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员密码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode23 合并K个有序链表</title>
      <link href="/2018/04/13/n23-merge-k-sorted-lists/"/>
      <url>/2018/04/13/n23-merge-k-sorted-lists/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第23题</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>合并k个有序链表，返回合并后的排序链表。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">LeetCode第21题-合并两个有序链表</a>的扩展。所以，一种思路是采用两两合并的算法进行合并，但是算法复杂度较高。<br>另外一种思路是采用最小堆法，算法步骤如下：</p><ol><li>将k个链表的头结点放入最小堆；</li><li>从堆中取出最小元素并插入结果链表中;</li><li>如果取出的最小元素还有下一个元素，将其放入最小堆中;</li><li>执行步骤<code>2</code>，直到堆中元素全部被取出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化返回的链表</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化最小堆：取链表的头节点</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            n = lists[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 注意ListNode对象不能应用&lt;或者&gt;运算符，所以引入链表下标。通过(n.val, i)即可完成元素比较。</span></span><br><span class="line">            heapq.heappush(heap, (n.val, i, n)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次取出堆中最小的元素，插入到返回链表中，然后再将下一个节点插入最小堆中</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            _, i, min_node = heapq.heappop(heap)</span><br><span class="line">            p.next = min_node</span><br><span class="line">            p = min_node</span><br><span class="line">            <span class="keyword">if</span> min_node.next:</span><br><span class="line">                heapq.heappush(heap, (min_node.next.val, i, min_node.next))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://tryanswer.github.io/2018/04/15/n24-swap-nodes-in-pairs/">LeetCode24 两两交换链表中的节点</a></li><li><a href="https://tryanswer.github.io/2018/04/20/n25-reverse-nodes-in-k-group/">LeetCode25 k个一组翻转链表</a></li><li><a href="http://www.hui-wang.info/2017/11/18/动画解释如何求单链表环入口点/">动画解释如何求单链表环入口点</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
